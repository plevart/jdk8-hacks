<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/java/lang </title>
</head><body id="SUNWwebrev">
<h2>src/share/classes/java/lang/Class.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev 6075 : Class.getAnnotaion() synchronization bottleneck and JEP-149 proposal</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any

</pre><hr></hr><pre>
2195                 c = c.getComponentType();
2196             }
2197             String baseName = c.getName();
2198             int index = baseName.lastIndexOf('.');
2199             if (index != -1) {
2200                 name = baseName.substring(0, index).replace('.', '/')
2201                     +"/"+name;
2202             }
2203         } else {
2204             name = name.substring(1);
2205         }
2206         return name;
2207     }
2208 
2209     /**
2210      * Reflection support.
2211      */
2212 
2213     // Caches for certain reflective results
2214     private static boolean useCaches = true;
<span class="changed">2215     private volatile transient SoftReference&lt;Field[]&gt; declaredFields;</span>
<span class="changed">2216     private volatile transient SoftReference&lt;Field[]&gt; publicFields;</span>
<span class="changed">2217     private volatile transient SoftReference&lt;Method[]&gt; declaredMethods;</span>
<span class="changed">2218     private volatile transient SoftReference&lt;Method[]&gt; publicMethods;</span>
<span class="changed">2219     private volatile transient SoftReference&lt;Constructor&lt;T&gt;[]&gt; declaredConstructors;</span>
<span class="changed">2220     private volatile transient SoftReference&lt;Constructor&lt;T&gt;[]&gt; publicConstructors;</span>



2221     // Intermediate results for getFields and getMethods
<span class="changed">2222     private volatile transient SoftReference&lt;Field[]&gt; declaredPublicFields;</span>
<span class="changed">2223     private volatile transient SoftReference&lt;Method[]&gt; declaredPublicMethods;</span>






























2224 
2225     // Incremented by the VM on each call to JVM TI RedefineClasses()
2226     // that redefines this class or a superclass.
2227     private volatile transient int classRedefinedCount = 0;
2228 
<span class="changed">2229     // Value of classRedefinedCount when we last cleared the cached values</span>
<span class="changed">2230     // that are sensitive to class redefinition.</span>
<span class="changed">2231     private volatile transient int lastRedefinedCount = 0;</span>
<span class="changed">2232 </span>
<span class="changed">2233     // Clears cached values that might possibly have been obsoleted by</span>
<span class="changed">2234     // a class redefinition.</span>
<span class="changed">2235     private void clearCachesOnClassRedefinition() {</span>
<span class="changed">2236         if (lastRedefinedCount != classRedefinedCount) {</span>
<span class="changed">2237             declaredFields = publicFields = declaredPublicFields = null;</span>
<span class="changed">2238             declaredMethods = publicMethods = declaredPublicMethods = null;</span>
<span class="changed">2239             declaredConstructors = publicConstructors = null;</span>
<span class="changed">2240             annotations = declaredAnnotations = null;</span>
<span class="changed">2241 </span>
<span class="changed">2242             // Use of "volatile" (and synchronization by caller in the case</span>
<span class="changed">2243             // of annotations) ensures that no thread sees the update to</span>
<span class="changed">2244             // lastRedefinedCount before seeing the caches cleared.</span>
<span class="changed">2245             // We do not guard against brief windows during which multiple</span>
<span class="changed">2246             // threads might redundantly work to fill an empty cache.</span>
<span class="changed">2247             lastRedefinedCount = classRedefinedCount;</span>
2248         }
2249     }
2250 
2251     // Generic signature handling
2252     private native String getGenericSignature();
2253 
2254     // Generic info repository; lazily initialized
2255     private transient ClassRepository genericInfo;
2256 
2257     // accessor for factory
2258     private GenericsFactory getFactory() {
2259         // create scope and factory
2260         return CoreReflectionFactory.make(this, ClassScope.make(this));
2261     }
2262 
2263     // accessor for generic info repository
2264     private ClassRepository getGenericInfo() {
2265         // lazily initialize repository if necessary
2266         if (genericInfo == null) {
2267             // create and cache generic info repository

</pre><hr></hr><pre>
2271         return genericInfo; //return cached repository
2272     }
2273 
2274     // Annotations handling
2275     private native byte[] getRawAnnotations();
2276 
2277     native ConstantPool getConstantPool();
2278 
2279     //
2280     //
2281     // java.lang.reflect.Field handling
2282     //
2283     //
2284 
2285     // Returns an array of "root" fields. These Field objects must NOT
2286     // be propagated to the outside world, but must instead be copied
2287     // via ReflectionFactory.copyField.
2288     private Field[] privateGetDeclaredFields(boolean publicOnly) {
2289         checkInitted();
2290         Field[] res = null;
<span class="changed">2291         if (useCaches) {</span>
<span class="changed">2292             clearCachesOnClassRedefinition();</span>
<span class="changed">2293             if (publicOnly) {</span>
<span class="changed">2294                 if (declaredPublicFields != null) {</span>
<span class="changed">2295                     res = declaredPublicFields.get();</span>
<span class="changed">2296                 }</span>
<span class="changed">2297             } else {</span>
<span class="changed">2298                 if (declaredFields != null) {</span>
<span class="changed">2299                     res = declaredFields.get();</span>
<span class="changed">2300                 }</span>
<span class="changed">2301             }</span>
2302             if (res != null) return res;
2303         }
2304         // No cached value available; request value from VM
2305         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
<span class="changed">2306         if (useCaches) {</span>
2307             if (publicOnly) {
<span class="changed">2308                 declaredPublicFields = new SoftReference&lt;&gt;(res);</span>
2309             } else {
<span class="changed">2310                 declaredFields = new SoftReference&lt;&gt;(res);</span>
2311             }
2312         }
2313         return res;
2314     }
2315 
2316     // Returns an array of "root" fields. These Field objects must NOT
2317     // be propagated to the outside world, but must instead be copied
2318     // via ReflectionFactory.copyField.
2319     private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {
2320         checkInitted();
2321         Field[] res = null;
<span class="changed">2322         if (useCaches) {</span>
<span class="changed">2323             clearCachesOnClassRedefinition();</span>
<span class="changed">2324             if (publicFields != null) {</span>
<span class="changed">2325                 res = publicFields.get();</span>
<span class="changed">2326             }</span>
2327             if (res != null) return res;
2328         }
2329 
2330         // No cached value available; compute value recursively.
2331         // Traverse in correct order for getField().
2332         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
2333         if (traversedInterfaces == null) {
2334             traversedInterfaces = new HashSet&lt;&gt;();
2335         }
2336 
2337         // Local fields
2338         Field[] tmp = privateGetDeclaredFields(true);
2339         addAll(fields, tmp);
2340 
2341         // Direct superinterfaces, recursively
2342         for (Class&lt;?&gt; c : getInterfaces()) {
2343             if (!traversedInterfaces.contains(c)) {
2344                 traversedInterfaces.add(c);
2345                 addAll(fields, c.privateGetPublicFields(traversedInterfaces));
2346             }
2347         }
2348 
2349         // Direct superclass, recursively
2350         if (!isInterface()) {
2351             Class&lt;?&gt; c = getSuperclass();
2352             if (c != null) {
2353                 addAll(fields, c.privateGetPublicFields(traversedInterfaces));
2354             }
2355         }
2356 
2357         res = new Field[fields.size()];
2358         fields.toArray(res);
<span class="changed">2359         if (useCaches) {</span>
<span class="changed">2360             publicFields = new SoftReference&lt;&gt;(res);</span>
2361         }
2362         return res;
2363     }
2364 
2365     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
2366         for (int i = 0; i &lt; o.length; i++) {
2367             c.add(o[i]);
2368         }
2369     }
2370 
2371 
2372     //
2373     //
2374     // java.lang.reflect.Constructor handling
2375     //
2376     //
2377 
2378     // Returns an array of "root" constructors. These Constructor
2379     // objects must NOT be propagated to the outside world, but must
2380     // instead be copied via ReflectionFactory.copyConstructor.
2381     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
2382         checkInitted();
2383         Constructor&lt;T&gt;[] res = null;
<span class="changed">2384         if (useCaches) {</span>
<span class="changed">2385             clearCachesOnClassRedefinition();</span>
<span class="changed">2386             if (publicOnly) {</span>
<span class="changed">2387                 if (publicConstructors != null) {</span>
<span class="changed">2388                     res = publicConstructors.get();</span>
<span class="changed">2389                 }</span>
<span class="changed">2390             } else {</span>
<span class="changed">2391                 if (declaredConstructors != null) {</span>
<span class="changed">2392                     res = declaredConstructors.get();</span>
<span class="changed">2393                 }</span>
<span class="changed">2394             }</span>
2395             if (res != null) return res;
2396         }
2397         // No cached value available; request value from VM
2398         if (isInterface()) {
2399             @SuppressWarnings("unchecked")
2400             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
2401             res = temporaryRes;
2402         } else {
2403             res = getDeclaredConstructors0(publicOnly);
2404         }
<span class="changed">2405         if (useCaches) {</span>
2406             if (publicOnly) {
<span class="changed">2407                 publicConstructors = new SoftReference&lt;&gt;(res);</span>
2408             } else {
<span class="changed">2409                 declaredConstructors = new SoftReference&lt;&gt;(res);</span>
2410             }
2411         }
2412         return res;
2413     }
2414 
2415     //
2416     //
2417     // java.lang.reflect.Method handling
2418     //
2419     //
2420 
2421     // Returns an array of "root" methods. These Method objects must NOT
2422     // be propagated to the outside world, but must instead be copied
2423     // via ReflectionFactory.copyMethod.
2424     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
2425         checkInitted();
2426         Method[] res = null;
<span class="changed">2427         if (useCaches) {</span>
<span class="changed">2428             clearCachesOnClassRedefinition();</span>
<span class="changed">2429             if (publicOnly) {</span>
<span class="changed">2430                 if (declaredPublicMethods != null) {</span>
<span class="changed">2431                     res = declaredPublicMethods.get();</span>
<span class="changed">2432                 }</span>
<span class="changed">2433             } else {</span>
<span class="changed">2434                 if (declaredMethods != null) {</span>
<span class="changed">2435                     res = declaredMethods.get();</span>
<span class="changed">2436                 }</span>
<span class="changed">2437             }</span>
2438             if (res != null) return res;
2439         }
2440         // No cached value available; request value from VM
2441         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
2442         if (useCaches) {
2443             if (publicOnly) {
<span class="changed">2444                 declaredPublicMethods = new SoftReference&lt;&gt;(res);</span>
2445             } else {
<span class="changed">2446                 declaredMethods = new SoftReference&lt;&gt;(res);</span>
2447             }
2448         }
2449         return res;
2450     }
2451 
2452     static class MethodArray {
2453         private Method[] methods;
2454         private int length;
2455 
2456         MethodArray() {
2457             methods = new Method[20];
2458             length = 0;
2459         }
2460 
2461         void add(Method m) {
2462             if (length == methods.length) {
2463                 methods = Arrays.copyOf(methods, 2 * methods.length);
2464             }
2465             methods[length++] = m;
2466         }

</pre><hr></hr><pre>
2529                     newPos++;
2530                 }
2531             }
2532             if (newPos != methods.length) {
2533                 methods = Arrays.copyOf(methods, newPos);
2534             }
2535         }
2536 
2537         Method[] getArray() {
2538             return methods;
2539         }
2540     }
2541 
2542 
2543     // Returns an array of "root" methods. These Method objects must NOT
2544     // be propagated to the outside world, but must instead be copied
2545     // via ReflectionFactory.copyMethod.
2546     private Method[] privateGetPublicMethods() {
2547         checkInitted();
2548         Method[] res = null;
<span class="changed">2549         if (useCaches) {</span>
<span class="changed">2550             clearCachesOnClassRedefinition();</span>
<span class="changed">2551             if (publicMethods != null) {</span>
<span class="changed">2552                 res = publicMethods.get();</span>
<span class="changed">2553             }</span>
2554             if (res != null) return res;
2555         }
2556 
2557         // No cached value available; compute value recursively.
2558         // Start by fetching public declared methods
2559         MethodArray methods = new MethodArray();
2560         {
2561                 Method[] tmp = privateGetDeclaredMethods(true);
2562             methods.addAll(tmp);
2563         }
2564         // Now recur over superclass and direct superinterfaces.
2565         // Go over superinterfaces first so we can more easily filter
2566         // out concrete implementations inherited from superclasses at
2567         // the end.
2568         MethodArray inheritedMethods = new MethodArray();
2569         Class&lt;?&gt;[] interfaces = getInterfaces();
2570         for (int i = 0; i &lt; interfaces.length; i++) {
2571             inheritedMethods.addAll(interfaces[i].privateGetPublicMethods());
2572         }
2573         if (!isInterface()) {

</pre><hr></hr><pre>
2581                     Method m = supers.get(i);
2582                     if (m != null &amp;&amp; !Modifier.isAbstract(m.getModifiers())) {
2583                         inheritedMethods.removeByNameAndSignature(m);
2584                     }
2585                 }
2586                 // Insert superclass's inherited methods before
2587                 // superinterfaces' to satisfy getMethod's search
2588                 // order
2589                 supers.addAll(inheritedMethods);
2590                 inheritedMethods = supers;
2591             }
2592         }
2593         // Filter out all local methods from inherited ones
2594         for (int i = 0; i &lt; methods.length(); i++) {
2595             Method m = methods.get(i);
2596             inheritedMethods.removeByNameAndSignature(m);
2597         }
2598         methods.addAllIfNotPresent(inheritedMethods);
2599         methods.compactAndTrim();
2600         res = methods.getArray();
<span class="changed">2601         if (useCaches) {</span>
<span class="changed">2602             publicMethods = new SoftReference&lt;&gt;(res);</span>
2603         }
2604         return res;
2605     }
2606 
2607 
2608     //
2609     // Helpers for fetchers of one field, method, or constructor
2610     //
2611 
<span class="changed">2612     private Field searchFields(Field[] fields, String name) {</span>
2613         String internedName = name.intern();
2614         for (int i = 0; i &lt; fields.length; i++) {
2615             if (fields[i].getName() == internedName) {
2616                 return getReflectionFactory().copyField(fields[i]);
2617             }
2618         }
2619         return null;
2620     }
2621 
2622     private Field getField0(String name) throws NoSuchFieldException {
2623         // Note: the intent is that the search algorithm this routine
2624         // uses be equivalent to the ordering imposed by
2625         // privateGetPublicFields(). It fetches only the declared
2626         // public fields for each class, however, to reduce the number
2627         // of Field objects which have to be created for the common
2628         // case where the field being requested is declared in the
2629         // class which is being queried.
2630         Field res = null;
2631         // Search declared public fields
2632         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {

</pre><hr></hr><pre>
3032      *    the class itself).
3033      * @since 1.5
3034      */
3035     @SuppressWarnings("unchecked")
3036     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3037         if (clazz.isAssignableFrom(this))
3038             return (Class&lt;? extends U&gt;) this;
3039         else
3040             throw new ClassCastException(this.toString());
3041     }
3042 
3043     /**
3044      * @throws NullPointerException {@inheritDoc}
3045      * @since 1.5
3046      */
3047     @SuppressWarnings("unchecked")
3048     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3049         if (annotationClass == null)
3050             throw new NullPointerException();
3051 
<span class="changed">3052         initAnnotationsIfNecessary();</span>
<span class="changed">3053         return (A) annotations.get(annotationClass);</span>
3054     }
3055 
3056     /**
3057      * @throws NullPointerException {@inheritDoc}
3058      * @since 1.5
3059      */
3060     public boolean isAnnotationPresent(
3061         Class&lt;? extends Annotation&gt; annotationClass) {
3062         if (annotationClass == null)
3063             throw new NullPointerException();
3064 
3065         return getAnnotation(annotationClass) != null;
3066     }
3067 
3068 
3069     /**
3070      * @since 1.5
3071      */
3072     public Annotation[] getAnnotations() {
<span class="changed">3073         initAnnotationsIfNecessary();</span>
<span class="changed">3074         return AnnotationParser.toArray(annotations);</span>
3075     }
3076 
3077     /**
3078      * @since 1.5
3079      */
3080     public Annotation[] getDeclaredAnnotations()  {
<span class="changed">3081         initAnnotationsIfNecessary();</span>
<span class="changed">3082         return AnnotationParser.toArray(declaredAnnotations);</span>
3083     }
3084 
<span class="removed">3085     // Annotations cache</span>
<span class="removed">3086     private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
<span class="removed">3087     private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span>
3088 
<span class="changed">3089     private synchronized void initAnnotationsIfNecessary() {</span>
<span class="changed">3090         clearCachesOnClassRedefinition();</span>
<span class="changed">3091         if (annotations != null)</span>
<span class="changed">3092             return;</span>
<span class="changed">3093         declaredAnnotations = AnnotationParser.parseAnnotations(</span>




3094             getRawAnnotations(), getConstantPool(), this);

3095         Class&lt;?&gt; superClass = getSuperclass();
3096         if (superClass == null) {
3097             annotations = declaredAnnotations;
3098         } else {
3099             annotations = new HashMap&lt;&gt;();
<span class="changed">3100             superClass.initAnnotationsIfNecessary();</span>
<span class="changed">3101             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superClass.annotations.entrySet()) {</span>
3102                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
3103                 if (AnnotationType.getInstance(annotationClass).isInherited())
3104                     annotations.put(annotationClass, e.getValue());
3105             }
3106             annotations.putAll(declaredAnnotations);
3107         }







3108     }
3109 
3110     // Annotation types cache their internal (AnnotationType) form
3111 
3112     private AnnotationType annotationType;
3113 
3114     void setAnnotationType(AnnotationType type) {
3115         annotationType = type;
3116     }
3117 
3118     AnnotationType getAnnotationType() {
3119         return annotationType;
3120     }
3121 
3122     /* Backing store of user-defined values pertaining to this class.
3123      * Maintained by the ClassValue class.
3124      */
3125     transient ClassValue.ClassValueMap classValueMap;
3126 }
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any

</pre><hr></hr><pre>
2195                 c = c.getComponentType();
2196             }
2197             String baseName = c.getName();
2198             int index = baseName.lastIndexOf('.');
2199             if (index != -1) {
2200                 name = baseName.substring(0, index).replace('.', '/')
2201                     +"/"+name;
2202             }
2203         } else {
2204             name = name.substring(1);
2205         }
2206         return name;
2207     }
2208 
2209     /**
2210      * Reflection support.
2211      */
2212 
2213     // Caches for certain reflective results
2214     private static boolean useCaches = true;
<span class="changed">2215 </span>
<span class="changed">2216     // volatile data that might get invalid when JVM TI RedefineClasses() is called</span>
<span class="changed">2217     static class VolatileData&lt;T&gt; {</span>
<span class="changed">2218         volatile Field[] declaredFields;</span>
<span class="changed">2219         volatile Field[] publicFields;</span>
<span class="changed">2220         volatile Method[] declaredMethods;</span>
<span class="changed">2221         volatile Method[] publicMethods;</span>
<span class="changed">2222         volatile Constructor&lt;T&gt;[] declaredConstructors;</span>
<span class="changed">2223         volatile Constructor&lt;T&gt;[] publicConstructors;</span>
2224         // Intermediate results for getFields and getMethods
<span class="changed">2225         volatile Field[] declaredPublicFields;</span>
<span class="changed">2226         volatile Method[] declaredPublicMethods;</span>
<span class="changed">2227         // Annotations</span>
<span class="changed">2228         volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
<span class="changed">2229         volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span>
<span class="changed">2230         // Value of classRedefinedCount when we created this VolatileData instance</span>
<span class="changed">2231         final int redefinedCount;</span>
<span class="changed">2232 </span>
<span class="changed">2233         VolatileData(int redefinedCount) {</span>
<span class="changed">2234             this.redefinedCount = redefinedCount;</span>
<span class="changed">2235         }</span>
<span class="changed">2236 </span>
<span class="changed">2237         // initialize Unsafe machinery here, since we need to call Class.class instance method and would like to avoid</span>
<span class="changed">2238         // calling it in the static initializer of the Class class...</span>
<span class="changed">2239         private static final Unsafe unsafe;</span>
<span class="changed">2240         // offset of Class.volatileData instance field</span>
<span class="changed">2241         private static final long volatileDataOffset;</span>
<span class="changed">2242 </span>
<span class="changed">2243         static {</span>
<span class="changed">2244             unsafe = Unsafe.getUnsafe();</span>
<span class="changed">2245             // bypass caches</span>
<span class="changed">2246             Field volatileDataField = searchFields(Class.class.getDeclaredFields0(false), "volatileData");</span>
<span class="changed">2247             if (volatileDataField == null) throw new Error("No volatileData field found in java.lang.Class");</span>
<span class="changed">2248             volatileDataOffset = unsafe.objectFieldOffset(volatileDataField);</span>
<span class="changed">2249         }</span>
<span class="changed">2250 </span>
<span class="changed">2251         static &lt;T&gt; boolean compareAndSwap(Class&lt;?&gt; clazz, SoftReference&lt;VolatileData&lt;T&gt;&gt; oldData, SoftReference&lt;VolatileData&lt;T&gt;&gt; newData) {</span>
<span class="changed">2252             return unsafe.compareAndSwapObject(clazz, volatileDataOffset, oldData, newData);</span>
<span class="changed">2253         }</span>
<span class="changed">2254     }</span>
<span class="changed">2255     </span>
<span class="changed">2256     private volatile transient SoftReference&lt;VolatileData&lt;T&gt;&gt; volatileData;</span>
2257 
2258     // Incremented by the VM on each call to JVM TI RedefineClasses()
2259     // that redefines this class or a superclass.
2260     private volatile transient int classRedefinedCount = 0;
2261 
<span class="changed">2262     // Lazily create and cache VolatileData</span>
<span class="changed">2263     private VolatileData&lt;T&gt; volatileData() {</span>
<span class="changed">2264         if (!useCaches) return null;</span>
<span class="changed">2265 </span>
<span class="changed">2266         while (true)</span>
<span class="changed">2267         {</span>
<span class="changed">2268             SoftReference&lt;VolatileData&lt;T&gt;&gt; volatileData = this.volatileData;</span>
<span class="changed">2269             int classRedefinedCount = this.classRedefinedCount;</span>
<span class="changed">2270             VolatileData&lt;T&gt; vd;</span>
<span class="changed">2271             if (volatileData != null &amp;&amp; (vd = volatileData.get()) != null &amp;&amp; vd.redefinedCount == classRedefinedCount) {</span>
<span class="changed">2272                 return vd;</span>
<span class="changed">2273             }</span>
<span class="changed">2274             // no SoftReference or cleared SoftReference or stale VolatileData</span>
<span class="changed">2275             vd = new VolatileData&lt;T&gt;(classRedefinedCount);</span>
<span class="changed">2276             // try to CAS it...</span>
<span class="changed">2277             if (VolatileData.compareAndSwap(this, volatileData, new SoftReference&lt;VolatileData&lt;T&gt;&gt;(vd))) {</span>
<span class="changed">2278                 return vd;</span>
<span class="changed">2279             }</span>
<span class="changed">2280             // else retry</span>
2281         }
2282     }
2283 
2284     // Generic signature handling
2285     private native String getGenericSignature();
2286 
2287     // Generic info repository; lazily initialized
2288     private transient ClassRepository genericInfo;
2289 
2290     // accessor for factory
2291     private GenericsFactory getFactory() {
2292         // create scope and factory
2293         return CoreReflectionFactory.make(this, ClassScope.make(this));
2294     }
2295 
2296     // accessor for generic info repository
2297     private ClassRepository getGenericInfo() {
2298         // lazily initialize repository if necessary
2299         if (genericInfo == null) {
2300             // create and cache generic info repository

</pre><hr></hr><pre>
2304         return genericInfo; //return cached repository
2305     }
2306 
2307     // Annotations handling
2308     private native byte[] getRawAnnotations();
2309 
2310     native ConstantPool getConstantPool();
2311 
2312     //
2313     //
2314     // java.lang.reflect.Field handling
2315     //
2316     //
2317 
2318     // Returns an array of "root" fields. These Field objects must NOT
2319     // be propagated to the outside world, but must instead be copied
2320     // via ReflectionFactory.copyField.
2321     private Field[] privateGetDeclaredFields(boolean publicOnly) {
2322         checkInitted();
2323         Field[] res = null;
<span class="changed">2324         VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="changed">2325         if (vd != null) {</span>
<span class="changed">2326             res = publicOnly ? vd.declaredPublicFields : vd.declaredFields;</span>








2327             if (res != null) return res;
2328         }
2329         // No cached value available; request value from VM
2330         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
<span class="changed">2331         if (vd != null) {</span>
2332             if (publicOnly) {
<span class="changed">2333                 vd.declaredPublicFields = res;</span>
2334             } else {
<span class="changed">2335                 vd.declaredFields = res;</span>
2336             }
2337         }
2338         return res;
2339     }
2340 
2341     // Returns an array of "root" fields. These Field objects must NOT
2342     // be propagated to the outside world, but must instead be copied
2343     // via ReflectionFactory.copyField.
2344     private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {
2345         checkInitted();
2346         Field[] res = null;
<span class="changed">2347         VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="changed">2348         if (vd != null) {</span>
<span class="changed">2349             res = vd.publicFields;</span>


2350             if (res != null) return res;
2351         }
2352 
2353         // No cached value available; compute value recursively.
2354         // Traverse in correct order for getField().
2355         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
2356         if (traversedInterfaces == null) {
2357             traversedInterfaces = new HashSet&lt;&gt;();
2358         }
2359 
2360         // Local fields
2361         Field[] tmp = privateGetDeclaredFields(true);
2362         addAll(fields, tmp);
2363 
2364         // Direct superinterfaces, recursively
2365         for (Class&lt;?&gt; c : getInterfaces()) {
2366             if (!traversedInterfaces.contains(c)) {
2367                 traversedInterfaces.add(c);
2368                 addAll(fields, c.privateGetPublicFields(traversedInterfaces));
2369             }
2370         }
2371 
2372         // Direct superclass, recursively
2373         if (!isInterface()) {
2374             Class&lt;?&gt; c = getSuperclass();
2375             if (c != null) {
2376                 addAll(fields, c.privateGetPublicFields(traversedInterfaces));
2377             }
2378         }
2379 
2380         res = new Field[fields.size()];
2381         fields.toArray(res);
<span class="changed">2382         if (vd != null) {</span>
<span class="changed">2383             vd.publicFields = res;</span>
2384         }
2385         return res;
2386     }
2387 
2388     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
2389         for (int i = 0; i &lt; o.length; i++) {
2390             c.add(o[i]);
2391         }
2392     }
2393 
2394 
2395     //
2396     //
2397     // java.lang.reflect.Constructor handling
2398     //
2399     //
2400 
2401     // Returns an array of "root" constructors. These Constructor
2402     // objects must NOT be propagated to the outside world, but must
2403     // instead be copied via ReflectionFactory.copyConstructor.
2404     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
2405         checkInitted();
2406         Constructor&lt;T&gt;[] res = null;
<span class="changed">2407         VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="changed">2408         if (vd != null) {</span>
<span class="changed">2409             res = publicOnly ? vd.publicConstructors : vd.declaredConstructors;</span>








2410             if (res != null) return res;
2411         }
2412         // No cached value available; request value from VM
2413         if (isInterface()) {
2414             @SuppressWarnings("unchecked")
2415             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
2416             res = temporaryRes;
2417         } else {
2418             res = getDeclaredConstructors0(publicOnly);
2419         }
<span class="changed">2420         if (vd != null) {</span>
2421             if (publicOnly) {
<span class="changed">2422                 vd.publicConstructors = res;</span>
2423             } else {
<span class="changed">2424                 vd.declaredConstructors = res;</span>
2425             }
2426         }
2427         return res;
2428     }
2429 
2430     //
2431     //
2432     // java.lang.reflect.Method handling
2433     //
2434     //
2435 
2436     // Returns an array of "root" methods. These Method objects must NOT
2437     // be propagated to the outside world, but must instead be copied
2438     // via ReflectionFactory.copyMethod.
2439     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
2440         checkInitted();
2441         Method[] res = null;
<span class="changed">2442         VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="changed">2443         if (vd != null) {</span>
<span class="changed">2444             res = publicOnly ? vd.declaredPublicMethods : vd.declaredMethods;</span>








2445             if (res != null) return res;
2446         }
2447         // No cached value available; request value from VM
2448         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
2449         if (useCaches) {
2450             if (publicOnly) {
<span class="changed">2451                 vd.declaredPublicMethods = res;</span>
2452             } else {
<span class="changed">2453                 vd.declaredMethods = res;</span>
2454             }
2455         }
2456         return res;
2457     }
2458 
2459     static class MethodArray {
2460         private Method[] methods;
2461         private int length;
2462 
2463         MethodArray() {
2464             methods = new Method[20];
2465             length = 0;
2466         }
2467 
2468         void add(Method m) {
2469             if (length == methods.length) {
2470                 methods = Arrays.copyOf(methods, 2 * methods.length);
2471             }
2472             methods[length++] = m;
2473         }

</pre><hr></hr><pre>
2536                     newPos++;
2537                 }
2538             }
2539             if (newPos != methods.length) {
2540                 methods = Arrays.copyOf(methods, newPos);
2541             }
2542         }
2543 
2544         Method[] getArray() {
2545             return methods;
2546         }
2547     }
2548 
2549 
2550     // Returns an array of "root" methods. These Method objects must NOT
2551     // be propagated to the outside world, but must instead be copied
2552     // via ReflectionFactory.copyMethod.
2553     private Method[] privateGetPublicMethods() {
2554         checkInitted();
2555         Method[] res = null;
<span class="changed">2556         VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="changed">2557         if (vd != null) {</span>
<span class="changed">2558             res = vd.publicMethods;</span>


2559             if (res != null) return res;
2560         }
2561 
2562         // No cached value available; compute value recursively.
2563         // Start by fetching public declared methods
2564         MethodArray methods = new MethodArray();
2565         {
2566             Method[] tmp = privateGetDeclaredMethods(true);
2567             methods.addAll(tmp);
2568         }
2569         // Now recur over superclass and direct superinterfaces.
2570         // Go over superinterfaces first so we can more easily filter
2571         // out concrete implementations inherited from superclasses at
2572         // the end.
2573         MethodArray inheritedMethods = new MethodArray();
2574         Class&lt;?&gt;[] interfaces = getInterfaces();
2575         for (int i = 0; i &lt; interfaces.length; i++) {
2576             inheritedMethods.addAll(interfaces[i].privateGetPublicMethods());
2577         }
2578         if (!isInterface()) {

</pre><hr></hr><pre>
2586                     Method m = supers.get(i);
2587                     if (m != null &amp;&amp; !Modifier.isAbstract(m.getModifiers())) {
2588                         inheritedMethods.removeByNameAndSignature(m);
2589                     }
2590                 }
2591                 // Insert superclass's inherited methods before
2592                 // superinterfaces' to satisfy getMethod's search
2593                 // order
2594                 supers.addAll(inheritedMethods);
2595                 inheritedMethods = supers;
2596             }
2597         }
2598         // Filter out all local methods from inherited ones
2599         for (int i = 0; i &lt; methods.length(); i++) {
2600             Method m = methods.get(i);
2601             inheritedMethods.removeByNameAndSignature(m);
2602         }
2603         methods.addAllIfNotPresent(inheritedMethods);
2604         methods.compactAndTrim();
2605         res = methods.getArray();
<span class="changed">2606         if (vd != null) {</span>
<span class="changed">2607             vd.publicMethods = res;</span>
2608         }
2609         return res;
2610     }
2611 
2612 
2613     //
2614     // Helpers for fetchers of one field, method, or constructor
2615     //
2616 
<span class="changed">2617     private static Field searchFields(Field[] fields, String name) {</span>
2618         String internedName = name.intern();
2619         for (int i = 0; i &lt; fields.length; i++) {
2620             if (fields[i].getName() == internedName) {
2621                 return getReflectionFactory().copyField(fields[i]);
2622             }
2623         }
2624         return null;
2625     }
2626 
2627     private Field getField0(String name) throws NoSuchFieldException {
2628         // Note: the intent is that the search algorithm this routine
2629         // uses be equivalent to the ordering imposed by
2630         // privateGetPublicFields(). It fetches only the declared
2631         // public fields for each class, however, to reduce the number
2632         // of Field objects which have to be created for the common
2633         // case where the field being requested is declared in the
2634         // class which is being queried.
2635         Field res = null;
2636         // Search declared public fields
2637         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {

</pre><hr></hr><pre>
3037      *    the class itself).
3038      * @since 1.5
3039      */
3040     @SuppressWarnings("unchecked")
3041     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3042         if (clazz.isAssignableFrom(this))
3043             return (Class&lt;? extends U&gt;) this;
3044         else
3045             throw new ClassCastException(this.toString());
3046     }
3047 
3048     /**
3049      * @throws NullPointerException {@inheritDoc}
3050      * @since 1.5
3051      */
3052     @SuppressWarnings("unchecked")
3053     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3054         if (annotationClass == null)
3055             throw new NullPointerException();
3056 
<span class="changed">3057         return (A) privateGetAnnotations(false).get(annotationClass);</span>

3058     }
3059 
3060     /**
3061      * @throws NullPointerException {@inheritDoc}
3062      * @since 1.5
3063      */
3064     public boolean isAnnotationPresent(
3065         Class&lt;? extends Annotation&gt; annotationClass) {
3066         if (annotationClass == null)
3067             throw new NullPointerException();
3068 
3069         return getAnnotation(annotationClass) != null;
3070     }
3071 
3072 
3073     /**
3074      * @since 1.5
3075      */
3076     public Annotation[] getAnnotations() {
<span class="changed">3077         return AnnotationParser.toArray(privateGetAnnotations(false));</span>

3078     }
3079 
3080     /**
3081      * @since 1.5
3082      */
3083     public Annotation[] getDeclaredAnnotations()  {
<span class="changed">3084         return AnnotationParser.toArray(privateGetAnnotations(true));</span>

3085     }
3086 



3087 
<span class="changed">3088     private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; privateGetAnnotations(boolean declaredOnly) {</span>
<span class="changed">3089         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; res;</span>
<span class="changed">3090         VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="changed">3091         if (vd != null) {</span>
<span class="changed">3092             res = declaredOnly ? vd.declaredAnnotations : vd.annotations;</span>
<span class="changed">3093             if (res != null) return res;</span>
<span class="changed">3094         }</span>
<span class="changed">3095 </span>
<span class="changed">3096         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations = AnnotationParser.parseAnnotations(</span>
3097             getRawAnnotations(), getConstantPool(), this);
<span class="new">3098         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
3099         Class&lt;?&gt; superClass = getSuperclass();
3100         if (superClass == null) {
3101             annotations = declaredAnnotations;
3102         } else {
3103             annotations = new HashMap&lt;&gt;();
<span class="changed">3104             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superClass.privateGetAnnotations(false).entrySet()) {</span>

3105                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
3106                 if (AnnotationType.getInstance(annotationClass).isInherited())
3107                     annotations.put(annotationClass, e.getValue());
3108             }
3109             annotations.putAll(declaredAnnotations);
3110         }
<span class="new">3111 </span>
<span class="new">3112         if (vd != null) {</span>
<span class="new">3113             vd.annotations = annotations;</span>
<span class="new">3114             vd.declaredAnnotations = declaredAnnotations;</span>
<span class="new">3115         }</span>
<span class="new">3116 </span>
<span class="new">3117         return declaredOnly ? declaredAnnotations : annotations;</span>
3118     }
3119 
3120     // Annotation types cache their internal (AnnotationType) form
3121 
3122     private AnnotationType annotationType;
3123 
3124     void setAnnotationType(AnnotationType type) {
3125         annotationType = type;
3126     }
3127 
3128     AnnotationType getAnnotationType() {
3129         return annotationType;
3130     }
3131 
3132     /* Backing store of user-defined values pertaining to this class.
3133      * Maintained by the ClassValue class.
3134      */
3135     transient ClassValue.ClassValueMap classValueMap;
3136 }
</pre></td>
</tr></table>
</body></html>
