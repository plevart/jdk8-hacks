<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev 6075 : Class.getAnnotaion() synchronization bottleneck and JEP-149 proposal</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.reflect.Array;
  29 import java.lang.reflect.GenericArrayType;
  30 import java.lang.reflect.Member;
  31 import java.lang.reflect.Field;
  32 import java.lang.reflect.Method;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Type;
  36 import java.lang.reflect.TypeVariable;
  37 import java.lang.reflect.InvocationTargetException;
  38 import java.lang.ref.SoftReference;
  39 import java.io.InputStream;
  40 import java.io.ObjectStreamField;
  41 import java.security.AccessController;
  42 import java.security.PrivilegedAction;
  43 import java.util.ArrayList;
  44 import java.util.Arrays;
  45 import java.util.Collection;
  46 import java.util.HashSet;
  47 import java.util.List;
  48 import java.util.Set;
  49 import java.util.Map;
  50 import java.util.HashMap;
  51 import sun.misc.Unsafe;
  52 import sun.reflect.ConstantPool;
  53 import sun.reflect.Reflection;
  54 import sun.reflect.ReflectionFactory;
  55 import sun.reflect.generics.factory.CoreReflectionFactory;
  56 import sun.reflect.generics.factory.GenericsFactory;
  57 import sun.reflect.generics.repository.ClassRepository;
  58 import sun.reflect.generics.repository.MethodRepository;
  59 import sun.reflect.generics.repository.ConstructorRepository;
  60 import sun.reflect.generics.scope.ClassScope;
  61 import sun.security.util.SecurityConstants;
  62 import java.lang.annotation.Annotation;
  63 import sun.reflect.annotation.*;
  64 
  65 /**
  66  * Instances of the class {@code Class} represent classes and
  67  * interfaces in a running Java application.  An enum is a kind of
  68  * class and an annotation is a kind of interface.  Every array also
  69  * belongs to a class that is reflected as a {@code Class} object
  70  * that is shared by all arrays with the same element type and number
  71  * of dimensions.  The primitive Java types ({@code boolean},
  72  * {@code byte}, {@code char}, {@code short},
  73  * {@code int}, {@code long}, {@code float}, and
  74  * {@code double}), and the keyword {@code void} are also
  75  * represented as {@code Class} objects.
  76  *
  77  * &lt;p&gt; {@code Class} has no public constructor. Instead {@code Class}
  78  * objects are constructed automatically by the Java Virtual Machine as classes
  79  * are loaded and by calls to the {@code defineClass} method in the class
  80  * loader.
  81  *
  82  * &lt;p&gt; The following example uses a {@code Class} object to print the
  83  * class name of an object:
  84  *
  85  * &lt;p&gt; &lt;blockquote&gt;&lt;pre&gt;
  86  *     void printClassName(Object obj) {
  87  *         System.out.println("The class of " + obj +
  88  *                            " is " + obj.getClass().getName());
  89  *     }
  90  * &lt;/pre&gt;&lt;/blockquote&gt;
  91  *
  92  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
  93  * type (or for void) using a class literal.  See Section 15.8.2 of
  94  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
  95  * For example:
  96  *
  97  * &lt;p&gt; &lt;blockquote&gt;
  98  *     {@code System.out.println("The name of class Foo is: "+Foo.class.getName());}
  99  * &lt;/blockquote&gt;
 100  *
 101  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 102  * object.  For example, the type of {@code String.class} is {@code
 103  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 104  * unknown.
 105  *
 106  * @author  unascribed
 107  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 108  * @since   JDK1.0
 109  */
 110 public final
 111     class Class&lt;T&gt; implements java.io.Serializable,
 112                               java.lang.reflect.GenericDeclaration,
 113                               java.lang.reflect.Type,
 114                               java.lang.reflect.AnnotatedElement {
 115     private static final int ANNOTATION= 0x00002000;
 116     private static final int ENUM      = 0x00004000;
 117     private static final int SYNTHETIC = 0x00001000;
 118 
 119     private static native void registerNatives();
 120     static {
 121         registerNatives();
 122     }
 123 
 124     /*
 125      * Constructor. Only the Java Virtual Machine creates Class
 126      * objects.
 127      */
 128     private Class() {}
 129 
 130 
 131     /**
 132      * Converts the object to a string. The string representation is the
 133      * string "class" or "interface", followed by a space, and then by the
 134      * fully qualified name of the class in the format returned by
 135      * {@code getName}.  If this {@code Class} object represents a
 136      * primitive type, this method returns the name of the primitive type.  If
 137      * this {@code Class} object represents void this method returns
 138      * "void".
 139      *
 140      * @return a string representation of this class object.
 141      */
 142     public String toString() {
 143         return (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))
 144             + getName();
 145     }
 146 
 147 
 148     /**
 149      * Returns the {@code Class} object associated with the class or
 150      * interface with the given string name.  Invoking this method is
 151      * equivalent to:
 152      *
 153      * &lt;blockquote&gt;
 154      *  {@code Class.forName(className, true, currentLoader)}
 155      * &lt;/blockquote&gt;
 156      *
 157      * where {@code currentLoader} denotes the defining class loader of
 158      * the current class.
 159      *
 160      * &lt;p&gt; For example, the following code fragment returns the
 161      * runtime {@code Class} descriptor for the class named
 162      * {@code java.lang.Thread}:
 163      *
 164      * &lt;blockquote&gt;
 165      *   {@code Class t = Class.forName("java.lang.Thread")}
 166      * &lt;/blockquote&gt;
 167      * &lt;p&gt;
 168      * A call to {@code forName("X")} causes the class named
 169      * {@code X} to be initialized.
 170      *
 171      * @param      className   the fully qualified name of the desired class.
 172      * @return     the {@code Class} object for the class with the
 173      *             specified name.
 174      * @exception LinkageError if the linkage fails
 175      * @exception ExceptionInInitializerError if the initialization provoked
 176      *            by this method fails
 177      * @exception ClassNotFoundException if the class cannot be located
 178      */
 179     public static Class&lt;?&gt; forName(String className)
 180                 throws ClassNotFoundException {
 181         return forName0(className, true, ClassLoader.getCallerClassLoader());
 182     }
 183 
 184 
 185     /**
 186      * Returns the {@code Class} object associated with the class or
 187      * interface with the given string name, using the given class loader.
 188      * Given the fully qualified name for a class or interface (in the same
 189      * format returned by {@code getName}) this method attempts to
 190      * locate, load, and link the class or interface.  The specified class
 191      * loader is used to load the class or interface.  If the parameter
 192      * {@code loader} is null, the class is loaded through the bootstrap
 193      * class loader.  The class is initialized only if the
 194      * {@code initialize} parameter is {@code true} and if it has
 195      * not been initialized earlier.
 196      *
 197      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 198      * will be made to locate a user-defined class in the unnamed package whose
 199      * name is {@code name}. Therefore, this method cannot be used to
 200      * obtain any of the {@code Class} objects representing primitive
 201      * types or void.
 202      *
 203      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 204      * the array class is loaded but not initialized.
 205      *
 206      * &lt;p&gt; For example, in an instance method the expression:
 207      *
 208      * &lt;blockquote&gt;
 209      *  {@code Class.forName("Foo")}
 210      * &lt;/blockquote&gt;
 211      *
 212      * is equivalent to:
 213      *
 214      * &lt;blockquote&gt;
 215      *  {@code Class.forName("Foo", true, this.getClass().getClassLoader())}
 216      * &lt;/blockquote&gt;
 217      *
 218      * Note that this method throws errors related to loading, linking or
 219      * initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The
 220      * Java Language Specification&lt;/em&gt;.
 221      * Note that this method does not check whether the requested class
 222      * is accessible to its caller.
 223      *
 224      * &lt;p&gt; If the {@code loader} is {@code null}, and a security
 225      * manager is present, and the caller's class loader is not null, then this
 226      * method calls the security manager's {@code checkPermission} method
 227      * with a {@code RuntimePermission("getClassLoader")} permission to
 228      * ensure it's ok to access the bootstrap class loader.
 229      *
 230      * @param name       fully qualified name of the desired class
 231      * @param initialize if {@code true} the class will be initialized.
 232      *                   See Section 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;.
 233      * @param loader     class loader from which the class must be loaded
 234      * @return           class object representing the desired class
 235      *
 236      * @exception LinkageError if the linkage fails
 237      * @exception ExceptionInInitializerError if the initialization provoked
 238      *            by this method fails
 239      * @exception ClassNotFoundException if the class cannot be located by
 240      *            the specified class loader
 241      *
 242      * @see       java.lang.Class#forName(String)
 243      * @see       java.lang.ClassLoader
 244      * @since     1.2
 245      */
 246     public static Class&lt;?&gt; forName(String name, boolean initialize,
 247                                    ClassLoader loader)
 248         throws ClassNotFoundException
 249     {
 250         if (loader == null) {
 251             SecurityManager sm = System.getSecurityManager();
 252             if (sm != null) {
 253                 ClassLoader ccl = ClassLoader.getCallerClassLoader();
 254                 if (ccl != null) {
 255                     sm.checkPermission(
 256                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 257                 }
 258             }
 259         }
 260         return forName0(name, initialize, loader);
 261     }
 262 
 263     /** Called after security checks have been made. */
 264     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 265                                             ClassLoader loader)
 266         throws ClassNotFoundException;
 267 
 268     /**
 269      * Creates a new instance of the class represented by this {@code Class}
 270      * object.  The class is instantiated as if by a {@code new}
 271      * expression with an empty argument list.  The class is initialized if it
 272      * has not already been initialized.
 273      *
 274      * &lt;p&gt;Note that this method propagates any exception thrown by the
 275      * nullary constructor, including a checked exception.  Use of
 276      * this method effectively bypasses the compile-time exception
 277      * checking that would otherwise be performed by the compiler.
 278      * The {@link
 279      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 280      * Constructor.newInstance} method avoids this problem by wrapping
 281      * any exception thrown by the constructor in a (checked) {@link
 282      * java.lang.reflect.InvocationTargetException}.
 283      *
 284      * @return     a newly allocated instance of the class represented by this
 285      *             object.
 286      * @exception  IllegalAccessException  if the class or its nullary
 287      *               constructor is not accessible.
 288      * @exception  InstantiationException
 289      *               if this {@code Class} represents an abstract class,
 290      *               an interface, an array class, a primitive type, or void;
 291      *               or if the class has no nullary constructor;
 292      *               or if the instantiation fails for some other reason.
 293      * @exception  ExceptionInInitializerError if the initialization
 294      *               provoked by this method fails.
 295      * @exception  SecurityException
 296      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
 297      *             following conditions is met:
 298      *
 299      *             &lt;ul&gt;
 300      *
 301      *             &lt;li&gt; invocation of
 302      *             {@link SecurityManager#checkMemberAccess
 303      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
 304      *             creation of new instances of this class
 305      *
 306      *             &lt;li&gt; the caller's class loader is not the same as or an
 307      *             ancestor of the class loader for the current class and
 308      *             invocation of {@link SecurityManager#checkPackageAccess
 309      *             s.checkPackageAccess()} denies access to the package
 310      *             of this class
 311      *
 312      *             &lt;/ul&gt;
 313      *
 314      */
 315     public T newInstance()
 316         throws InstantiationException, IllegalAccessException
 317     {
 318         if (System.getSecurityManager() != null) {
 319             checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
 320         }
 321         return newInstance0();
 322     }
 323 
 324     private T newInstance0()
 325         throws InstantiationException, IllegalAccessException
 326     {
 327         // NOTE: the following code may not be strictly correct under
 328         // the current Java memory model.
 329 
 330         // Constructor lookup
 331         if (cachedConstructor == null) {
 332             if (this == Class.class) {
 333                 throw new IllegalAccessException(
 334                     "Can not call newInstance() on the Class for java.lang.Class"
 335                 );
 336             }
 337             try {
 338                 Class&lt;?&gt;[] empty = {};
 339                 final Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);
 340                 // Disable accessibility checks on the constructor
 341                 // since we have to do the security check here anyway
 342                 // (the stack depth is wrong for the Constructor's
 343                 // security check to work)
 344                 java.security.AccessController.doPrivileged(
 345                     new java.security.PrivilegedAction&lt;Void&gt;() {
 346                         public Void run() {
 347                                 c.setAccessible(true);
 348                                 return null;
 349                             }
 350                         });
 351                 cachedConstructor = c;
 352             } catch (NoSuchMethodException e) {
 353                 throw (InstantiationException)
 354                     new InstantiationException(getName()).initCause(e);
 355             }
 356         }
 357         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 358         // Security check (same as in java.lang.reflect.Constructor)
 359         int modifiers = tmpConstructor.getModifiers();
 360         if (!Reflection.quickCheckMemberAccess(this, modifiers)) {
 361             Class&lt;?&gt; caller = Reflection.getCallerClass(3);
 362             if (newInstanceCallerCache != caller) {
 363                 Reflection.ensureMemberAccess(caller, this, null, modifiers);
 364                 newInstanceCallerCache = caller;
 365             }
 366         }
 367         // Run constructor
 368         try {
 369             return tmpConstructor.newInstance((Object[])null);
 370         } catch (InvocationTargetException e) {
 371             Unsafe.getUnsafe().throwException(e.getTargetException());
 372             // Not reached
 373             return null;
 374         }
 375     }
 376     private volatile transient Constructor&lt;T&gt; cachedConstructor;
 377     private volatile transient Class&lt;?&gt;       newInstanceCallerCache;
 378 
 379 
 380     /**
 381      * Determines if the specified {@code Object} is assignment-compatible
 382      * with the object represented by this {@code Class}.  This method is
 383      * the dynamic equivalent of the Java language {@code instanceof}
 384      * operator. The method returns {@code true} if the specified
 385      * {@code Object} argument is non-null and can be cast to the
 386      * reference type represented by this {@code Class} object without
 387      * raising a {@code ClassCastException.} It returns {@code false}
 388      * otherwise.
 389      *
 390      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 391      * declared class, this method returns {@code true} if the specified
 392      * {@code Object} argument is an instance of the represented class (or
 393      * of any of its subclasses); it returns {@code false} otherwise. If
 394      * this {@code Class} object represents an array class, this method
 395      * returns {@code true} if the specified {@code Object} argument
 396      * can be converted to an object of the array class by an identity
 397      * conversion or by a widening reference conversion; it returns
 398      * {@code false} otherwise. If this {@code Class} object
 399      * represents an interface, this method returns {@code true} if the
 400      * class or any superclass of the specified {@code Object} argument
 401      * implements this interface; it returns {@code false} otherwise. If
 402      * this {@code Class} object represents a primitive type, this method
 403      * returns {@code false}.
 404      *
 405      * @param   obj the object to check
 406      * @return  true if {@code obj} is an instance of this class
 407      *
 408      * @since JDK1.1
 409      */
 410     public native boolean isInstance(Object obj);
 411 
 412 
 413     /**
 414      * Determines if the class or interface represented by this
 415      * {@code Class} object is either the same as, or is a superclass or
 416      * superinterface of, the class or interface represented by the specified
 417      * {@code Class} parameter. It returns {@code true} if so;
 418      * otherwise it returns {@code false}. If this {@code Class}
 419      * object represents a primitive type, this method returns
 420      * {@code true} if the specified {@code Class} parameter is
 421      * exactly this {@code Class} object; otherwise it returns
 422      * {@code false}.
 423      *
 424      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 425      * specified {@code Class} parameter can be converted to the type
 426      * represented by this {@code Class} object via an identity conversion
 427      * or via a widening reference conversion. See &lt;em&gt;The Java Language
 428      * Specification&lt;/em&gt;, sections 5.1.1 and 5.1.4 , for details.
 429      *
 430      * @param cls the {@code Class} object to be checked
 431      * @return the {@code boolean} value indicating whether objects of the
 432      * type {@code cls} can be assigned to objects of this class
 433      * @exception NullPointerException if the specified Class parameter is
 434      *            null.
 435      * @since JDK1.1
 436      */
 437     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 438 
 439 
 440     /**
 441      * Determines if the specified {@code Class} object represents an
 442      * interface type.
 443      *
 444      * @return  {@code true} if this object represents an interface;
 445      *          {@code false} otherwise.
 446      */
 447     public native boolean isInterface();
 448 
 449 
 450     /**
 451      * Determines if this {@code Class} object represents an array class.
 452      *
 453      * @return  {@code true} if this object represents an array class;
 454      *          {@code false} otherwise.
 455      * @since   JDK1.1
 456      */
 457     public native boolean isArray();
 458 
 459 
 460     /**
 461      * Determines if the specified {@code Class} object represents a
 462      * primitive type.
 463      *
 464      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 465      * the eight primitive types and void.  These are created by the Java
 466      * Virtual Machine, and have the same names as the primitive types that
 467      * they represent, namely {@code boolean}, {@code byte},
 468      * {@code char}, {@code short}, {@code int},
 469      * {@code long}, {@code float}, and {@code double}.
 470      *
 471      * &lt;p&gt; These objects may only be accessed via the following public static
 472      * final variables, and are the only {@code Class} objects for which
 473      * this method returns {@code true}.
 474      *
 475      * @return true if and only if this class represents a primitive type
 476      *
 477      * @see     java.lang.Boolean#TYPE
 478      * @see     java.lang.Character#TYPE
 479      * @see     java.lang.Byte#TYPE
 480      * @see     java.lang.Short#TYPE
 481      * @see     java.lang.Integer#TYPE
 482      * @see     java.lang.Long#TYPE
 483      * @see     java.lang.Float#TYPE
 484      * @see     java.lang.Double#TYPE
 485      * @see     java.lang.Void#TYPE
 486      * @since JDK1.1
 487      */
 488     public native boolean isPrimitive();
 489 
 490     /**
 491      * Returns true if this {@code Class} object represents an annotation
 492      * type.  Note that if this method returns true, {@link #isInterface()}
 493      * would also return true, as all annotation types are also interfaces.
 494      *
 495      * @return {@code true} if this class object represents an annotation
 496      *      type; {@code false} otherwise
 497      * @since 1.5
 498      */
 499     public boolean isAnnotation() {
 500         return (getModifiers() &amp; ANNOTATION) != 0;
 501     }
 502 
 503     /**
 504      * Returns {@code true} if this class is a synthetic class;
 505      * returns {@code false} otherwise.
 506      * @return {@code true} if and only if this class is a synthetic class as
 507      *         defined by the Java Language Specification.
 508      * @since 1.5
 509      */
 510     public boolean isSynthetic() {
 511         return (getModifiers() &amp; SYNTHETIC) != 0;
 512     }
 513 
 514     /**
 515      * Returns the  name of the entity (class, interface, array class,
 516      * primitive type, or void) represented by this {@code Class} object,
 517      * as a {@code String}.
 518      *
 519      * &lt;p&gt; If this class object represents a reference type that is not an
 520      * array type then the binary name of the class is returned, as specified
 521      * by
 522      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 523      *
 524      * &lt;p&gt; If this class object represents a primitive type or void, then the
 525      * name returned is a {@code String} equal to the Java language
 526      * keyword corresponding to the primitive type or void.
 527      *
 528      * &lt;p&gt; If this class object represents a class of arrays, then the internal
 529      * form of the name consists of the name of the element type preceded by
 530      * one or more '{@code [}' characters representing the depth of the array
 531      * nesting.  The encoding of element type names is as follows:
 532      *
 533      * &lt;blockquote&gt;&lt;table summary="Element types and encodings"&gt;
 534      * &lt;tr&gt;&lt;th&gt; Element Type &lt;th&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;th&gt; Encoding
 535      * &lt;tr&gt;&lt;td&gt; boolean      &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; Z
 536      * &lt;tr&gt;&lt;td&gt; byte         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; B
 537      * &lt;tr&gt;&lt;td&gt; char         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; C
 538      * &lt;tr&gt;&lt;td&gt; class or interface
 539      *                       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; L&lt;i&gt;classname&lt;/i&gt;;
 540      * &lt;tr&gt;&lt;td&gt; double       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; D
 541      * &lt;tr&gt;&lt;td&gt; float        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; F
 542      * &lt;tr&gt;&lt;td&gt; int          &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; I
 543      * &lt;tr&gt;&lt;td&gt; long         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; J
 544      * &lt;tr&gt;&lt;td&gt; short        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; S
 545      * &lt;/table&gt;&lt;/blockquote&gt;
 546      *
 547      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 548      * the class specified above.
 549      *
 550      * &lt;p&gt; Examples:
 551      * &lt;blockquote&gt;&lt;pre&gt;
 552      * String.class.getName()
 553      *     returns "java.lang.String"
 554      * byte.class.getName()
 555      *     returns "byte"
 556      * (new Object[3]).getClass().getName()
 557      *     returns "[Ljava.lang.Object;"
 558      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 559      *     returns "[[[[[[[I"
 560      * &lt;/pre&gt;&lt;/blockquote&gt;
 561      *
 562      * @return  the name of the class or interface
 563      *          represented by this object.
 564      */
 565     public String getName() {
 566         String name = this.name;
 567         if (name == null)
 568             this.name = name = getName0();
 569         return name;
 570     }
 571 
 572     // cache the name to reduce the number of calls into the VM
 573     private transient String name;
 574     private native String getName0();
 575 
 576     /**
 577      * Returns the class loader for the class.  Some implementations may use
 578      * null to represent the bootstrap class loader. This method will return
 579      * null in such implementations if this class was loaded by the bootstrap
 580      * class loader.
 581      *
 582      * &lt;p&gt; If a security manager is present, and the caller's class loader is
 583      * not null and the caller's class loader is not the same as or an ancestor of
 584      * the class loader for the class whose class loader is requested, then
 585      * this method calls the security manager's {@code checkPermission}
 586      * method with a {@code RuntimePermission("getClassLoader")}
 587      * permission to ensure it's ok to access the class loader for the class.
 588      *
 589      * &lt;p&gt;If this object
 590      * represents a primitive type or void, null is returned.
 591      *
 592      * @return  the class loader that loaded the class or interface
 593      *          represented by this object.
 594      * @throws SecurityException
 595      *    if a security manager exists and its
 596      *    {@code checkPermission} method denies
 597      *    access to the class loader for the class.
 598      * @see java.lang.ClassLoader
 599      * @see SecurityManager#checkPermission
 600      * @see java.lang.RuntimePermission
 601      */
 602     public ClassLoader getClassLoader() {
 603         ClassLoader cl = getClassLoader0();
 604         if (cl == null)
 605             return null;
 606         SecurityManager sm = System.getSecurityManager();
 607         if (sm != null) {
 608             ClassLoader ccl = ClassLoader.getCallerClassLoader();
 609             if (ClassLoader.needsClassLoaderPermissionCheck(ccl, cl)) {
 610                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 611             }
 612         }
 613         return cl;
 614     }
 615 
 616     // Package-private to allow ClassLoader access
 617     native ClassLoader getClassLoader0();
 618 
 619 
 620     /**
 621      * Returns an array of {@code TypeVariable} objects that represent the
 622      * type variables declared by the generic declaration represented by this
 623      * {@code GenericDeclaration} object, in declaration order.  Returns an
 624      * array of length 0 if the underlying generic declaration declares no type
 625      * variables.
 626      *
 627      * @return an array of {@code TypeVariable} objects that represent
 628      *     the type variables declared by this generic declaration
 629      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 630      *     signature of this generic declaration does not conform to
 631      *     the format specified in
 632      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 633      * @since 1.5
 634      */
 635     @SuppressWarnings("unchecked")
 636     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 637         if (getGenericSignature() != null)
 638             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])getGenericInfo().getTypeParameters();
 639         else
 640             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 641     }
 642 
 643 
 644     /**
 645      * Returns the {@code Class} representing the superclass of the entity
 646      * (class, interface, primitive type or void) represented by this
 647      * {@code Class}.  If this {@code Class} represents either the
 648      * {@code Object} class, an interface, a primitive type, or void, then
 649      * null is returned.  If this object represents an array class then the
 650      * {@code Class} object representing the {@code Object} class is
 651      * returned.
 652      *
 653      * @return the superclass of the class represented by this object.
 654      */
 655     public native Class&lt;? super T&gt; getSuperclass();
 656 
 657 
 658     /**
 659      * Returns the {@code Type} representing the direct superclass of
 660      * the entity (class, interface, primitive type or void) represented by
 661      * this {@code Class}.
 662      *
 663      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 664      * object returned must accurately reflect the actual type
 665      * parameters used in the source code. The parameterized type
 666      * representing the superclass is created if it had not been
 667      * created before. See the declaration of {@link
 668      * java.lang.reflect.ParameterizedType ParameterizedType} for the
 669      * semantics of the creation process for parameterized types.  If
 670      * this {@code Class} represents either the {@code Object}
 671      * class, an interface, a primitive type, or void, then null is
 672      * returned.  If this object represents an array class then the
 673      * {@code Class} object representing the {@code Object} class is
 674      * returned.
 675      *
 676      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 677      *     class signature does not conform to the format specified in
 678      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 679      * @throws TypeNotPresentException if the generic superclass
 680      *     refers to a non-existent type declaration
 681      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
 682      *     generic superclass refers to a parameterized type that cannot be
 683      *     instantiated  for any reason
 684      * @return the superclass of the class represented by this object
 685      * @since 1.5
 686      */
 687     public Type getGenericSuperclass() {
 688         if (getGenericSignature() != null) {
 689             // Historical irregularity:
 690             // Generic signature marks interfaces with superclass = Object
 691             // but this API returns null for interfaces
 692             if (isInterface())
 693                 return null;
 694             return getGenericInfo().getSuperclass();
 695         } else
 696             return getSuperclass();
 697     }
 698 
 699     /**
 700      * Gets the package for this class.  The class loader of this class is used
 701      * to find the package.  If the class was loaded by the bootstrap class
 702      * loader the set of packages loaded from CLASSPATH is searched to find the
 703      * package of the class. Null is returned if no package object was created
 704      * by the class loader of this class.
 705      *
 706      * &lt;p&gt; Packages have attributes for versions and specifications only if the
 707      * information was defined in the manifests that accompany the classes, and
 708      * if the class loader created the package instance with the attributes
 709      * from the manifest.
 710      *
 711      * @return the package of the class, or null if no package
 712      *         information is available from the archive or codebase.
 713      */
 714     public Package getPackage() {
 715         return Package.getPackage(this);
 716     }
 717 
 718 
 719     /**
 720      * Determines the interfaces implemented by the class or interface
 721      * represented by this object.
 722      *
 723      * &lt;p&gt; If this object represents a class, the return value is an array
 724      * containing objects representing all interfaces implemented by the
 725      * class. The order of the interface objects in the array corresponds to
 726      * the order of the interface names in the {@code implements} clause
 727      * of the declaration of the class represented by this object. For
 728      * example, given the declaration:
 729      * &lt;blockquote&gt;
 730      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
 731      * &lt;/blockquote&gt;
 732      * suppose the value of {@code s} is an instance of
 733      * {@code Shimmer}; the value of the expression:
 734      * &lt;blockquote&gt;
 735      * {@code s.getClass().getInterfaces()[0]}
 736      * &lt;/blockquote&gt;
 737      * is the {@code Class} object that represents interface
 738      * {@code FloorWax}; and the value of:
 739      * &lt;blockquote&gt;
 740      * {@code s.getClass().getInterfaces()[1]}
 741      * &lt;/blockquote&gt;
 742      * is the {@code Class} object that represents interface
 743      * {@code DessertTopping}.
 744      *
 745      * &lt;p&gt; If this object represents an interface, the array contains objects
 746      * representing all interfaces extended by the interface. The order of the
 747      * interface objects in the array corresponds to the order of the interface
 748      * names in the {@code extends} clause of the declaration of the
 749      * interface represented by this object.
 750      *
 751      * &lt;p&gt; If this object represents a class or interface that implements no
 752      * interfaces, the method returns an array of length 0.
 753      *
 754      * &lt;p&gt; If this object represents a primitive type or void, the method
 755      * returns an array of length 0.
 756      *
 757      * @return an array of interfaces implemented by this class.
 758      */
 759     public native Class&lt;?&gt;[] getInterfaces();
 760 
 761     /**
 762      * Returns the {@code Type}s representing the interfaces
 763      * directly implemented by the class or interface represented by
 764      * this object.
 765      *
 766      * &lt;p&gt;If a superinterface is a parameterized type, the
 767      * {@code Type} object returned for it must accurately reflect
 768      * the actual type parameters used in the source code. The
 769      * parameterized type representing each superinterface is created
 770      * if it had not been created before. See the declaration of
 771      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
 772      * for the semantics of the creation process for parameterized
 773      * types.
 774      *
 775      * &lt;p&gt; If this object represents a class, the return value is an
 776      * array containing objects representing all interfaces
 777      * implemented by the class. The order of the interface objects in
 778      * the array corresponds to the order of the interface names in
 779      * the {@code implements} clause of the declaration of the class
 780      * represented by this object.  In the case of an array class, the
 781      * interfaces {@code Cloneable} and {@code Serializable} are
 782      * returned in that order.
 783      *
 784      * &lt;p&gt;If this object represents an interface, the array contains
 785      * objects representing all interfaces directly extended by the
 786      * interface.  The order of the interface objects in the array
 787      * corresponds to the order of the interface names in the
 788      * {@code extends} clause of the declaration of the interface
 789      * represented by this object.
 790      *
 791      * &lt;p&gt;If this object represents a class or interface that
 792      * implements no interfaces, the method returns an array of length
 793      * 0.
 794      *
 795      * &lt;p&gt;If this object represents a primitive type or void, the
 796      * method returns an array of length 0.
 797      *
 798      * @throws java.lang.reflect.GenericSignatureFormatError
 799      *     if the generic class signature does not conform to the format
 800      *     specified in
 801      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 802      * @throws TypeNotPresentException if any of the generic
 803      *     superinterfaces refers to a non-existent type declaration
 804      * @throws java.lang.reflect.MalformedParameterizedTypeException
 805      *     if any of the generic superinterfaces refer to a parameterized
 806      *     type that cannot be instantiated for any reason
 807      * @return an array of interfaces implemented by this class
 808      * @since 1.5
 809      */
 810     public Type[] getGenericInterfaces() {
 811         if (getGenericSignature() != null)
 812             return getGenericInfo().getSuperInterfaces();
 813         else
 814             return getInterfaces();
 815     }
 816 
 817 
 818     /**
 819      * Returns the {@code Class} representing the component type of an
 820      * array.  If this class does not represent an array class this method
 821      * returns null.
 822      *
 823      * @return the {@code Class} representing the component type of this
 824      * class if this class is an array
 825      * @see     java.lang.reflect.Array
 826      * @since JDK1.1
 827      */
 828     public native Class&lt;?&gt; getComponentType();
 829 
 830 
 831     /**
 832      * Returns the Java language modifiers for this class or interface, encoded
 833      * in an integer. The modifiers consist of the Java Virtual Machine's
 834      * constants for {@code public}, {@code protected},
 835      * {@code private}, {@code final}, {@code static},
 836      * {@code abstract} and {@code interface}; they should be decoded
 837      * using the methods of class {@code Modifier}.
 838      *
 839      * &lt;p&gt; If the underlying class is an array class, then its
 840      * {@code public}, {@code private} and {@code protected}
 841      * modifiers are the same as those of its component type.  If this
 842      * {@code Class} represents a primitive type or void, its
 843      * {@code public} modifier is always {@code true}, and its
 844      * {@code protected} and {@code private} modifiers are always
 845      * {@code false}. If this object represents an array class, a
 846      * primitive type or void, then its {@code final} modifier is always
 847      * {@code true} and its interface modifier is always
 848      * {@code false}. The values of its other modifiers are not determined
 849      * by this specification.
 850      *
 851      * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine
 852      * Specification&lt;/em&gt;, table 4.1.
 853      *
 854      * @return the {@code int} representing the modifiers for this class
 855      * @see     java.lang.reflect.Modifier
 856      * @since JDK1.1
 857      */
 858     public native int getModifiers();
 859 
 860 
 861     /**
 862      * Gets the signers of this class.
 863      *
 864      * @return  the signers of this class, or null if there are no signers.  In
 865      *          particular, this method returns null if this object represents
 866      *          a primitive type or void.
 867      * @since   JDK1.1
 868      */
 869     public native Object[] getSigners();
 870 
 871 
 872     /**
 873      * Set the signers of this class.
 874      */
 875     native void setSigners(Object[] signers);
 876 
 877 
 878     /**
 879      * If this {@code Class} object represents a local or anonymous
 880      * class within a method, returns a {@link
 881      * java.lang.reflect.Method Method} object representing the
 882      * immediately enclosing method of the underlying class. Returns
 883      * {@code null} otherwise.
 884      *
 885      * In particular, this method returns {@code null} if the underlying
 886      * class is a local or anonymous class immediately enclosed by a type
 887      * declaration, instance initializer or static initializer.
 888      *
 889      * @return the immediately enclosing method of the underlying class, if
 890      *     that class is a local or anonymous class; otherwise {@code null}.
 891      * @since 1.5
 892      */
 893     public Method getEnclosingMethod() {
 894         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
 895 
 896         if (enclosingInfo == null)
 897             return null;
 898         else {
 899             if (!enclosingInfo.isMethod())
 900                 return null;
 901 
 902             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
 903                                                               getFactory());
 904             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
 905             Type []    parameterTypes   = typeInfo.getParameterTypes();
 906             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
 907 
 908             // Convert Types to Classes; returned types *should*
 909             // be class objects since the methodDescriptor's used
 910             // don't have generics information
 911             for(int i = 0; i &lt; parameterClasses.length; i++)
 912                 parameterClasses[i] = toClass(parameterTypes[i]);
 913 
 914             /*
 915              * Loop over all declared methods; match method name,
 916              * number of and type of parameters, *and* return
 917              * type.  Matching return type is also necessary
 918              * because of covariant returns, etc.
 919              */
 920             for(Method m: enclosingInfo.getEnclosingClass().getDeclaredMethods()) {
 921                 if (m.getName().equals(enclosingInfo.getName()) ) {
 922                     Class&lt;?&gt;[] candidateParamClasses = m.getParameterTypes();
 923                     if (candidateParamClasses.length == parameterClasses.length) {
 924                         boolean matches = true;
 925                         for(int i = 0; i &lt; candidateParamClasses.length; i++) {
 926                             if (!candidateParamClasses[i].equals(parameterClasses[i])) {
 927                                 matches = false;
 928                                 break;
 929                             }
 930                         }
 931 
 932                         if (matches) { // finally, check return type
 933                             if (m.getReturnType().equals(returnType) )
 934                                 return m;
 935                         }
 936                     }
 937                 }
 938             }
 939 
 940             throw new InternalError("Enclosing method not found");
 941         }
 942     }
 943 
 944     private native Object[] getEnclosingMethod0();
 945 
 946     private EnclosingMethodInfo getEnclosingMethodInfo() {
 947         Object[] enclosingInfo = getEnclosingMethod0();
 948         if (enclosingInfo == null)
 949             return null;
 950         else {
 951             return new EnclosingMethodInfo(enclosingInfo);
 952         }
 953     }
 954 
 955     private final static class EnclosingMethodInfo {
 956         private Class&lt;?&gt; enclosingClass;
 957         private String name;
 958         private String descriptor;
 959 
 960         private EnclosingMethodInfo(Object[] enclosingInfo) {
 961             if (enclosingInfo.length != 3)
 962                 throw new InternalError("Malformed enclosing method information");
 963             try {
 964                 // The array is expected to have three elements:
 965 
 966                 // the immediately enclosing class
 967                 enclosingClass = (Class&lt;?&gt;) enclosingInfo[0];
 968                 assert(enclosingClass != null);
 969 
 970                 // the immediately enclosing method or constructor's
 971                 // name (can be null).
 972                 name            = (String)   enclosingInfo[1];
 973 
 974                 // the immediately enclosing method or constructor's
 975                 // descriptor (null iff name is).
 976                 descriptor      = (String)   enclosingInfo[2];
 977                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
 978             } catch (ClassCastException cce) {
 979                 throw new InternalError("Invalid type in enclosing method information", cce);
 980             }
 981         }
 982 
 983         boolean isPartial() {
 984             return enclosingClass == null || name == null || descriptor == null;
 985         }
 986 
 987         boolean isConstructor() { return !isPartial() &amp;&amp; "&lt;init&gt;".equals(name); }
 988 
 989         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !"&lt;clinit&gt;".equals(name); }
 990 
 991         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
 992 
 993         String getName() { return name; }
 994 
 995         String getDescriptor() { return descriptor; }
 996 
 997     }
 998 
 999     private static Class&lt;?&gt; toClass(Type o) {
1000         if (o instanceof GenericArrayType)
1001             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1002                                      0)
1003                 .getClass();
1004         return (Class&lt;?&gt;)o;
1005      }
1006 
1007     /**
1008      * If this {@code Class} object represents a local or anonymous
1009      * class within a constructor, returns a {@link
1010      * java.lang.reflect.Constructor Constructor} object representing
1011      * the immediately enclosing constructor of the underlying
1012      * class. Returns {@code null} otherwise.  In particular, this
1013      * method returns {@code null} if the underlying class is a local
1014      * or anonymous class immediately enclosed by a type declaration,
1015      * instance initializer or static initializer.
1016      *
1017      * @return the immediately enclosing constructor of the underlying class, if
1018      *     that class is a local or anonymous class; otherwise {@code null}.
1019      * @since 1.5
1020      */
1021     public Constructor&lt;?&gt; getEnclosingConstructor() {
1022         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1023 
1024         if (enclosingInfo == null)
1025             return null;
1026         else {
1027             if (!enclosingInfo.isConstructor())
1028                 return null;
1029 
1030             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1031                                                                         getFactory());
1032             Type []    parameterTypes   = typeInfo.getParameterTypes();
1033             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1034 
1035             // Convert Types to Classes; returned types *should*
1036             // be class objects since the methodDescriptor's used
1037             // don't have generics information
1038             for(int i = 0; i &lt; parameterClasses.length; i++)
1039                 parameterClasses[i] = toClass(parameterTypes[i]);
1040 
1041             /*
1042              * Loop over all declared constructors; match number
1043              * of and type of parameters.
1044              */
1045             for(Constructor&lt;?&gt; c: enclosingInfo.getEnclosingClass().getDeclaredConstructors()) {
1046                 Class&lt;?&gt;[] candidateParamClasses = c.getParameterTypes();
1047                 if (candidateParamClasses.length == parameterClasses.length) {
1048                     boolean matches = true;
1049                     for(int i = 0; i &lt; candidateParamClasses.length; i++) {
1050                         if (!candidateParamClasses[i].equals(parameterClasses[i])) {
1051                             matches = false;
1052                             break;
1053                         }
1054                     }
1055 
1056                     if (matches)
1057                         return c;
1058                 }
1059             }
1060 
1061             throw new InternalError("Enclosing constructor not found");
1062         }
1063     }
1064 
1065 
1066     /**
1067      * If the class or interface represented by this {@code Class} object
1068      * is a member of another class, returns the {@code Class} object
1069      * representing the class in which it was declared.  This method returns
1070      * null if this class or interface is not a member of any other class.  If
1071      * this {@code Class} object represents an array class, a primitive
1072      * type, or void,then this method returns null.
1073      *
1074      * @return the declaring class for this class
1075      * @since JDK1.1
1076      */
1077     public native Class&lt;?&gt; getDeclaringClass();
1078 
1079 
1080     /**
1081      * Returns the immediately enclosing class of the underlying
1082      * class.  If the underlying class is a top level class this
1083      * method returns {@code null}.
1084      * @return the immediately enclosing class of the underlying class
1085      * @since 1.5
1086      */
1087     public Class&lt;?&gt; getEnclosingClass() {
1088         // There are five kinds of classes (or interfaces):
1089         // a) Top level classes
1090         // b) Nested classes (static member classes)
1091         // c) Inner classes (non-static member classes)
1092         // d) Local classes (named classes declared within a method)
1093         // e) Anonymous classes
1094 
1095 
1096         // JVM Spec 4.8.6: A class must have an EnclosingMethod
1097         // attribute if and only if it is a local class or an
1098         // anonymous class.
1099         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1100 
1101         if (enclosingInfo == null) {
1102             // This is a top level or a nested class or an inner class (a, b, or c)
1103             return getDeclaringClass();
1104         } else {
1105             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1106             // This is a local class or an anonymous class (d or e)
1107             if (enclosingClass == this || enclosingClass == null)
1108                 throw new InternalError("Malformed enclosing method information");
1109             else
1110                 return enclosingClass;
1111         }
1112     }
1113 
1114     /**
1115      * Returns the simple name of the underlying class as given in the
1116      * source code. Returns an empty string if the underlying class is
1117      * anonymous.
1118      *
1119      * &lt;p&gt;The simple name of an array is the simple name of the
1120      * component type with "[]" appended.  In particular the simple
1121      * name of an array whose component type is anonymous is "[]".
1122      *
1123      * @return the simple name of the underlying class
1124      * @since 1.5
1125      */
1126     public String getSimpleName() {
1127         if (isArray())
1128             return getComponentType().getSimpleName()+"[]";
1129 
1130         String simpleName = getSimpleBinaryName();
1131         if (simpleName == null) { // top level class
1132             simpleName = getName();
1133             return simpleName.substring(simpleName.lastIndexOf(".")+1); // strip the package name
1134         }
1135         // According to JLS3 "Binary Compatibility" (13.1) the binary
1136         // name of non-package classes (not top level) is the binary
1137         // name of the immediately enclosing class followed by a '$' followed by:
1138         // (for nested and inner classes): the simple name.
1139         // (for local classes): 1 or more digits followed by the simple name.
1140         // (for anonymous classes): 1 or more digits.
1141 
1142         // Since getSimpleBinaryName() will strip the binary name of
1143         // the immediatly enclosing class, we are now looking at a
1144         // string that matches the regular expression "\$[0-9]*"
1145         // followed by a simple name (considering the simple of an
1146         // anonymous class to be the empty string).
1147 
1148         // Remove leading "\$[0-9]*" from the name
1149         int length = simpleName.length();
1150         if (length &lt; 1 || simpleName.charAt(0) != '$')
1151             throw new InternalError("Malformed class name");
1152         int index = 1;
1153         while (index &lt; length &amp;&amp; isAsciiDigit(simpleName.charAt(index)))
1154             index++;
1155         // Eventually, this is the empty string iff this is an anonymous class
1156         return simpleName.substring(index);
1157     }
1158 
1159     /**
1160      * Character.isDigit answers {@code true} to some non-ascii
1161      * digits.  This one does not.
1162      */
1163     private static boolean isAsciiDigit(char c) {
1164         return '0' &lt;= c &amp;&amp; c &lt;= '9';
1165     }
1166 
1167     /**
1168      * Returns the canonical name of the underlying class as
1169      * defined by the Java Language Specification.  Returns null if
1170      * the underlying class does not have a canonical name (i.e., if
1171      * it is a local or anonymous class or an array whose component
1172      * type does not have a canonical name).
1173      * @return the canonical name of the underlying class if it exists, and
1174      * {@code null} otherwise.
1175      * @since 1.5
1176      */
1177     public String getCanonicalName() {
1178         if (isArray()) {
1179             String canonicalName = getComponentType().getCanonicalName();
1180             if (canonicalName != null)
1181                 return canonicalName + "[]";
1182             else
1183                 return null;
1184         }
1185         if (isLocalOrAnonymousClass())
1186             return null;
1187         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1188         if (enclosingClass == null) { // top level class
1189             return getName();
1190         } else {
1191             String enclosingName = enclosingClass.getCanonicalName();
1192             if (enclosingName == null)
1193                 return null;
1194             return enclosingName + "." + getSimpleName();
1195         }
1196     }
1197 
1198     /**
1199      * Returns {@code true} if and only if the underlying class
1200      * is an anonymous class.
1201      *
1202      * @return {@code true} if and only if this class is an anonymous class.
1203      * @since 1.5
1204      */
1205     public boolean isAnonymousClass() {
1206         return "".equals(getSimpleName());
1207     }
1208 
1209     /**
1210      * Returns {@code true} if and only if the underlying class
1211      * is a local class.
1212      *
1213      * @return {@code true} if and only if this class is a local class.
1214      * @since 1.5
1215      */
1216     public boolean isLocalClass() {
1217         return isLocalOrAnonymousClass() &amp;&amp; !isAnonymousClass();
1218     }
1219 
1220     /**
1221      * Returns {@code true} if and only if the underlying class
1222      * is a member class.
1223      *
1224      * @return {@code true} if and only if this class is a member class.
1225      * @since 1.5
1226      */
1227     public boolean isMemberClass() {
1228         return getSimpleBinaryName() != null &amp;&amp; !isLocalOrAnonymousClass();
1229     }
1230 
1231     /**
1232      * Returns the "simple binary name" of the underlying class, i.e.,
1233      * the binary name without the leading enclosing class name.
1234      * Returns {@code null} if the underlying class is a top level
1235      * class.
1236      */
1237     private String getSimpleBinaryName() {
1238         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1239         if (enclosingClass == null) // top level class
1240             return null;
1241         // Otherwise, strip the enclosing class' name
1242         try {
1243             return getName().substring(enclosingClass.getName().length());
1244         } catch (IndexOutOfBoundsException ex) {
1245             throw new InternalError("Malformed class name", ex);
1246         }
1247     }
1248 
1249     /**
1250      * Returns {@code true} if this is a local class or an anonymous
1251      * class.  Returns {@code false} otherwise.
1252      */
1253     private boolean isLocalOrAnonymousClass() {
1254         // JVM Spec 4.8.6: A class must have an EnclosingMethod
1255         // attribute if and only if it is a local class or an
1256         // anonymous class.
1257         return getEnclosingMethodInfo() != null;
1258     }
1259 
1260     /**
1261      * Returns an array containing {@code Class} objects representing all
1262      * the public classes and interfaces that are members of the class
1263      * represented by this {@code Class} object.  This includes public
1264      * class and interface members inherited from superclasses and public class
1265      * and interface members declared by the class.  This method returns an
1266      * array of length 0 if this {@code Class} object has no public member
1267      * classes or interfaces.  This method also returns an array of length 0 if
1268      * this {@code Class} object represents a primitive type, an array
1269      * class, or void.
1270      *
1271      * @return the array of {@code Class} objects representing the public
1272      * members of this class
1273      * @exception  SecurityException
1274      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1275      *             following conditions is met:
1276      *
1277      *             &lt;ul&gt;
1278      *
1279      *             &lt;li&gt; invocation of
1280      *             {@link SecurityManager#checkMemberAccess
1281      *             s.checkMemberAccess(this, Member.PUBLIC)} method
1282      *             denies access to the classes within this class
1283      *
1284      *             &lt;li&gt; the caller's class loader is not the same as or an
1285      *             ancestor of the class loader for the current class and
1286      *             invocation of {@link SecurityManager#checkPackageAccess
1287      *             s.checkPackageAccess()} denies access to the package
1288      *             of this class
1289      *
1290      *             &lt;/ul&gt;
1291      *
1292      * @since JDK1.1
1293      */
1294     public Class&lt;?&gt;[] getClasses() {
1295         // be very careful not to change the stack depth of this
1296         // checkMemberAccess call for security reasons
1297         // see java.lang.SecurityManager.checkMemberAccess
1298         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1299 
1300         // Privileged so this implementation can look at DECLARED classes,
1301         // something the caller might not have privilege to do.  The code here
1302         // is allowed to look at DECLARED classes because (1) it does not hand
1303         // out anything other than public members and (2) public member access
1304         // has already been ok'd by the SecurityManager.
1305 
1306         return java.security.AccessController.doPrivileged(
1307             new java.security.PrivilegedAction&lt;Class&lt;?&gt;[]&gt;() {
1308                 public Class&lt;?&gt;[] run() {
1309                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1310                     Class&lt;?&gt; currentClass = Class.this;
1311                     while (currentClass != null) {
1312                         Class&lt;?&gt;[] members = currentClass.getDeclaredClasses();
1313                         for (int i = 0; i &lt; members.length; i++) {
1314                             if (Modifier.isPublic(members[i].getModifiers())) {
1315                                 list.add(members[i]);
1316                             }
1317                         }
1318                         currentClass = currentClass.getSuperclass();
1319                     }
1320                     return list.toArray(new Class&lt;?&gt;[0]);
1321                 }
1322             });
1323     }
1324 
1325 
1326     /**
1327      * Returns an array containing {@code Field} objects reflecting all
1328      * the accessible public fields of the class or interface represented by
1329      * this {@code Class} object.  The elements in the array returned are
1330      * not sorted and are not in any particular order.  This method returns an
1331      * array of length 0 if the class or interface has no accessible public
1332      * fields, or if it represents an array class, a primitive type, or void.
1333      *
1334      * &lt;p&gt; Specifically, if this {@code Class} object represents a class,
1335      * this method returns the public fields of this class and of all its
1336      * superclasses.  If this {@code Class} object represents an
1337      * interface, this method returns the fields of this interface and of all
1338      * its superinterfaces.
1339      *
1340      * &lt;p&gt; The implicit length field for array class is not reflected by this
1341      * method. User code should use the methods of class {@code Array} to
1342      * manipulate arrays.
1343      *
1344      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.3.
1345      *
1346      * @return the array of {@code Field} objects representing the
1347      * public fields
1348      * @exception  SecurityException
1349      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1350      *             following conditions is met:
1351      *
1352      *             &lt;ul&gt;
1353      *
1354      *             &lt;li&gt; invocation of
1355      *             {@link SecurityManager#checkMemberAccess
1356      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
1357      *             access to the fields within this class
1358      *
1359      *             &lt;li&gt; the caller's class loader is not the same as or an
1360      *             ancestor of the class loader for the current class and
1361      *             invocation of {@link SecurityManager#checkPackageAccess
1362      *             s.checkPackageAccess()} denies access to the package
1363      *             of this class
1364      *
1365      *             &lt;/ul&gt;
1366      *
1367      * @since JDK1.1
1368      */
1369     public Field[] getFields() throws SecurityException {
1370         // be very careful not to change the stack depth of this
1371         // checkMemberAccess call for security reasons
1372         // see java.lang.SecurityManager.checkMemberAccess
1373         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1374         return copyFields(privateGetPublicFields(null));
1375     }
1376 
1377 
1378     /**
1379      * Returns an array containing {@code Method} objects reflecting all
1380      * the public &lt;em&gt;member&lt;/em&gt; methods of the class or interface represented
1381      * by this {@code Class} object, including those declared by the class
1382      * or interface and those inherited from superclasses and
1383      * superinterfaces.  Array classes return all the (public) member methods
1384      * inherited from the {@code Object} class.  The elements in the array
1385      * returned are not sorted and are not in any particular order.  This
1386      * method returns an array of length 0 if this {@code Class} object
1387      * represents a class or interface that has no public member methods, or if
1388      * this {@code Class} object represents a primitive type or void.
1389      *
1390      * &lt;p&gt; The class initialization method {@code &lt;clinit&gt;} is not
1391      * included in the returned array. If the class declares multiple public
1392      * member methods with the same parameter types, they are all included in
1393      * the returned array.
1394      *
1395      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.4.
1396      *
1397      * @return the array of {@code Method} objects representing the
1398      * public methods of this class
1399      * @exception  SecurityException
1400      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1401      *             following conditions is met:
1402      *
1403      *             &lt;ul&gt;
1404      *
1405      *             &lt;li&gt; invocation of
1406      *             {@link SecurityManager#checkMemberAccess
1407      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
1408      *             access to the methods within this class
1409      *
1410      *             &lt;li&gt; the caller's class loader is not the same as or an
1411      *             ancestor of the class loader for the current class and
1412      *             invocation of {@link SecurityManager#checkPackageAccess
1413      *             s.checkPackageAccess()} denies access to the package
1414      *             of this class
1415      *
1416      *             &lt;/ul&gt;
1417      *
1418      * @since JDK1.1
1419      */
1420     public Method[] getMethods() throws SecurityException {
1421         // be very careful not to change the stack depth of this
1422         // checkMemberAccess call for security reasons
1423         // see java.lang.SecurityManager.checkMemberAccess
1424         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1425         return copyMethods(privateGetPublicMethods());
1426     }
1427 
1428 
1429     /**
1430      * Returns an array containing {@code Constructor} objects reflecting
1431      * all the public constructors of the class represented by this
1432      * {@code Class} object.  An array of length 0 is returned if the
1433      * class has no public constructors, or if the class is an array class, or
1434      * if the class reflects a primitive type or void.
1435      *
1436      * Note that while this method returns an array of {@code
1437      * Constructor&lt;T&gt;} objects (that is an array of constructors from
1438      * this class), the return type of this method is {@code
1439      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
1440      * might be expected.  This less informative return type is
1441      * necessary since after being returned from this method, the
1442      * array could be modified to hold {@code Constructor} objects for
1443      * different classes, which would violate the type guarantees of
1444      * {@code Constructor&lt;T&gt;[]}.
1445      *
1446      * @return the array of {@code Constructor} objects representing the
1447      *  public constructors of this class
1448      * @exception  SecurityException
1449      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1450      *             following conditions is met:
1451      *
1452      *             &lt;ul&gt;
1453      *
1454      *             &lt;li&gt; invocation of
1455      *             {@link SecurityManager#checkMemberAccess
1456      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
1457      *             access to the constructors within this class
1458      *
1459      *             &lt;li&gt; the caller's class loader is not the same as or an
1460      *             ancestor of the class loader for the current class and
1461      *             invocation of {@link SecurityManager#checkPackageAccess
1462      *             s.checkPackageAccess()} denies access to the package
1463      *             of this class
1464      *
1465      *             &lt;/ul&gt;
1466      *
1467      * @since JDK1.1
1468      */
1469     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
1470         // be very careful not to change the stack depth of this
1471         // checkMemberAccess call for security reasons
1472         // see java.lang.SecurityManager.checkMemberAccess
1473         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1474         return copyConstructors(privateGetDeclaredConstructors(true));
1475     }
1476 
1477 
1478     /**
1479      * Returns a {@code Field} object that reflects the specified public
1480      * member field of the class or interface represented by this
1481      * {@code Class} object. The {@code name} parameter is a
1482      * {@code String} specifying the simple name of the desired field.
1483      *
1484      * &lt;p&gt; The field to be reflected is determined by the algorithm that
1485      * follows.  Let C be the class represented by this object:
1486      * &lt;OL&gt;
1487      * &lt;LI&gt; If C declares a public field with the name specified, that is the
1488      *      field to be reflected.&lt;/LI&gt;
1489      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
1490      *      recursively to each direct superinterface of C. The direct
1491      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
1492      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
1493      *      superclass S, then this algorithm is invoked recursively upon S.
1494      *      If C has no superclass, then a {@code NoSuchFieldException}
1495      *      is thrown.&lt;/LI&gt;
1496      * &lt;/OL&gt;
1497      *
1498      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.3.
1499      *
1500      * @param name the field name
1501      * @return  the {@code Field} object of this class specified by
1502      * {@code name}
1503      * @exception NoSuchFieldException if a field with the specified name is
1504      *              not found.
1505      * @exception NullPointerException if {@code name} is {@code null}
1506      * @exception  SecurityException
1507      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1508      *             following conditions is met:
1509      *
1510      *             &lt;ul&gt;
1511      *
1512      *             &lt;li&gt; invocation of
1513      *             {@link SecurityManager#checkMemberAccess
1514      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
1515      *             access to the field
1516      *
1517      *             &lt;li&gt; the caller's class loader is not the same as or an
1518      *             ancestor of the class loader for the current class and
1519      *             invocation of {@link SecurityManager#checkPackageAccess
1520      *             s.checkPackageAccess()} denies access to the package
1521      *             of this class
1522      *
1523      *             &lt;/ul&gt;
1524      *
1525      * @since JDK1.1
1526      */
1527     public Field getField(String name)
1528         throws NoSuchFieldException, SecurityException {
1529         // be very careful not to change the stack depth of this
1530         // checkMemberAccess call for security reasons
1531         // see java.lang.SecurityManager.checkMemberAccess
1532         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1533         Field field = getField0(name);
1534         if (field == null) {
1535             throw new NoSuchFieldException(name);
1536         }
1537         return field;
1538     }
1539 
1540 
1541     /**
1542      * Returns a {@code Method} object that reflects the specified public
1543      * member method of the class or interface represented by this
1544      * {@code Class} object. The {@code name} parameter is a
1545      * {@code String} specifying the simple name of the desired method. The
1546      * {@code parameterTypes} parameter is an array of {@code Class}
1547      * objects that identify the method's formal parameter types, in declared
1548      * order. If {@code parameterTypes} is {@code null}, it is
1549      * treated as if it were an empty array.
1550      *
1551      * &lt;p&gt; If the {@code name} is "{@code &lt;init&gt;};"or "{@code &lt;clinit&gt;}" a
1552      * {@code NoSuchMethodException} is raised. Otherwise, the method to
1553      * be reflected is determined by the algorithm that follows.  Let C be the
1554      * class represented by this object:
1555      * &lt;OL&gt;
1556      * &lt;LI&gt; C is searched for any &lt;I&gt;matching methods&lt;/I&gt;. If no matching
1557      *      method is found, the algorithm of step 1 is invoked recursively on
1558      *      the superclass of C.&lt;/LI&gt;
1559      * &lt;LI&gt; If no method was found in step 1 above, the superinterfaces of C
1560      *      are searched for a matching method. If any such method is found, it
1561      *      is reflected.&lt;/LI&gt;
1562      * &lt;/OL&gt;
1563      *
1564      * To find a matching method in a class C:&amp;nbsp; If C declares exactly one
1565      * public method with the specified name and exactly the same formal
1566      * parameter types, that is the method reflected. If more than one such
1567      * method is found in C, and one of these methods has a return type that is
1568      * more specific than any of the others, that method is reflected;
1569      * otherwise one of the methods is chosen arbitrarily.
1570      *
1571      * &lt;p&gt;Note that there may be more than one matching method in a
1572      * class because while the Java language forbids a class to
1573      * declare multiple methods with the same signature but different
1574      * return types, the Java virtual machine does not.  This
1575      * increased flexibility in the virtual machine can be used to
1576      * implement various language features.  For example, covariant
1577      * returns can be implemented with {@linkplain
1578      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
1579      * method and the method being overridden would have the same
1580      * signature but different return types.
1581      *
1582      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.4.
1583      *
1584      * @param name the name of the method
1585      * @param parameterTypes the list of parameters
1586      * @return the {@code Method} object that matches the specified
1587      * {@code name} and {@code parameterTypes}
1588      * @exception NoSuchMethodException if a matching method is not found
1589      *            or if the name is "&amp;lt;init&amp;gt;"or "&amp;lt;clinit&amp;gt;".
1590      * @exception NullPointerException if {@code name} is {@code null}
1591      * @exception  SecurityException
1592      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1593      *             following conditions is met:
1594      *
1595      *             &lt;ul&gt;
1596      *
1597      *             &lt;li&gt; invocation of
1598      *             {@link SecurityManager#checkMemberAccess
1599      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
1600      *             access to the method
1601      *
1602      *             &lt;li&gt; the caller's class loader is not the same as or an
1603      *             ancestor of the class loader for the current class and
1604      *             invocation of {@link SecurityManager#checkPackageAccess
1605      *             s.checkPackageAccess()} denies access to the package
1606      *             of this class
1607      *
1608      *             &lt;/ul&gt;
1609      *
1610      * @since JDK1.1
1611      */
1612     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
1613         throws NoSuchMethodException, SecurityException {
1614         // be very careful not to change the stack depth of this
1615         // checkMemberAccess call for security reasons
1616         // see java.lang.SecurityManager.checkMemberAccess
1617         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1618         Method method = getMethod0(name, parameterTypes);
1619         if (method == null) {
1620             throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
1621         }
1622         return method;
1623     }
1624 
1625 
1626     /**
1627      * Returns a {@code Constructor} object that reflects the specified
1628      * public constructor of the class represented by this {@code Class}
1629      * object. The {@code parameterTypes} parameter is an array of
1630      * {@code Class} objects that identify the constructor's formal
1631      * parameter types, in declared order.
1632      *
1633      * If this {@code Class} object represents an inner class
1634      * declared in a non-static context, the formal parameter types
1635      * include the explicit enclosing instance as the first parameter.
1636      *
1637      * &lt;p&gt; The constructor to reflect is the public constructor of the class
1638      * represented by this {@code Class} object whose formal parameter
1639      * types match those specified by {@code parameterTypes}.
1640      *
1641      * @param parameterTypes the parameter array
1642      * @return the {@code Constructor} object of the public constructor that
1643      * matches the specified {@code parameterTypes}
1644      * @exception NoSuchMethodException if a matching method is not found.
1645      * @exception  SecurityException
1646      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1647      *             following conditions is met:
1648      *
1649      *             &lt;ul&gt;
1650      *
1651      *             &lt;li&gt; invocation of
1652      *             {@link SecurityManager#checkMemberAccess
1653      *             s.checkMemberAccess(this, Member.PUBLIC)} denies
1654      *             access to the constructor
1655      *
1656      *             &lt;li&gt; the caller's class loader is not the same as or an
1657      *             ancestor of the class loader for the current class and
1658      *             invocation of {@link SecurityManager#checkPackageAccess
1659      *             s.checkPackageAccess()} denies access to the package
1660      *             of this class
1661      *
1662      *             &lt;/ul&gt;
1663      *
1664      * @since JDK1.1
1665      */
1666     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
1667         throws NoSuchMethodException, SecurityException {
1668         // be very careful not to change the stack depth of this
1669         // checkMemberAccess call for security reasons
1670         // see java.lang.SecurityManager.checkMemberAccess
1671         checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
1672         return getConstructor0(parameterTypes, Member.PUBLIC);
1673     }
1674 
1675 
1676     /**
1677      * Returns an array of {@code Class} objects reflecting all the
1678      * classes and interfaces declared as members of the class represented by
1679      * this {@code Class} object. This includes public, protected, default
1680      * (package) access, and private classes and interfaces declared by the
1681      * class, but excludes inherited classes and interfaces.  This method
1682      * returns an array of length 0 if the class declares no classes or
1683      * interfaces as members, or if this {@code Class} object represents a
1684      * primitive type, an array class, or void.
1685      *
1686      * @return the array of {@code Class} objects representing all the
1687      * declared members of this class
1688      * @exception  SecurityException
1689      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1690      *             following conditions is met:
1691      *
1692      *             &lt;ul&gt;
1693      *
1694      *             &lt;li&gt; invocation of
1695      *             {@link SecurityManager#checkMemberAccess
1696      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1697      *             access to the declared classes within this class
1698      *
1699      *             &lt;li&gt; the caller's class loader is not the same as or an
1700      *             ancestor of the class loader for the current class and
1701      *             invocation of {@link SecurityManager#checkPackageAccess
1702      *             s.checkPackageAccess()} denies access to the package
1703      *             of this class
1704      *
1705      *             &lt;/ul&gt;
1706      *
1707      * @since JDK1.1
1708      */
1709     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
1710         // be very careful not to change the stack depth of this
1711         // checkMemberAccess call for security reasons
1712         // see java.lang.SecurityManager.checkMemberAccess
1713         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
1714         return getDeclaredClasses0();
1715     }
1716 
1717 
1718     /**
1719      * Returns an array of {@code Field} objects reflecting all the fields
1720      * declared by the class or interface represented by this
1721      * {@code Class} object. This includes public, protected, default
1722      * (package) access, and private fields, but excludes inherited fields.
1723      * The elements in the array returned are not sorted and are not in any
1724      * particular order.  This method returns an array of length 0 if the class
1725      * or interface declares no fields, or if this {@code Class} object
1726      * represents a primitive type, an array class, or void.
1727      *
1728      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.3.
1729      *
1730      * @return    the array of {@code Field} objects representing all the
1731      * declared fields of this class
1732      * @exception  SecurityException
1733      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1734      *             following conditions is met:
1735      *
1736      *             &lt;ul&gt;
1737      *
1738      *             &lt;li&gt; invocation of
1739      *             {@link SecurityManager#checkMemberAccess
1740      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1741      *             access to the declared fields within this class
1742      *
1743      *             &lt;li&gt; the caller's class loader is not the same as or an
1744      *             ancestor of the class loader for the current class and
1745      *             invocation of {@link SecurityManager#checkPackageAccess
1746      *             s.checkPackageAccess()} denies access to the package
1747      *             of this class
1748      *
1749      *             &lt;/ul&gt;
1750      *
1751      * @since JDK1.1
1752      */
1753     public Field[] getDeclaredFields() throws SecurityException {
1754         // be very careful not to change the stack depth of this
1755         // checkMemberAccess call for security reasons
1756         // see java.lang.SecurityManager.checkMemberAccess
1757         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
1758         return copyFields(privateGetDeclaredFields(false));
1759     }
1760 
1761 
1762     /**
1763      * Returns an array of {@code Method} objects reflecting all the
1764      * methods declared by the class or interface represented by this
1765      * {@code Class} object. This includes public, protected, default
1766      * (package) access, and private methods, but excludes inherited methods.
1767      * The elements in the array returned are not sorted and are not in any
1768      * particular order.  This method returns an array of length 0 if the class
1769      * or interface declares no methods, or if this {@code Class} object
1770      * represents a primitive type, an array class, or void.  The class
1771      * initialization method {@code &lt;clinit&gt;} is not included in the
1772      * returned array. If the class declares multiple public member methods
1773      * with the same parameter types, they are all included in the returned
1774      * array.
1775      *
1776      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.
1777      *
1778      * @return    the array of {@code Method} objects representing all the
1779      * declared methods of this class
1780      * @exception  SecurityException
1781      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1782      *             following conditions is met:
1783      *
1784      *             &lt;ul&gt;
1785      *
1786      *             &lt;li&gt; invocation of
1787      *             {@link SecurityManager#checkMemberAccess
1788      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1789      *             access to the declared methods within this class
1790      *
1791      *             &lt;li&gt; the caller's class loader is not the same as or an
1792      *             ancestor of the class loader for the current class and
1793      *             invocation of {@link SecurityManager#checkPackageAccess
1794      *             s.checkPackageAccess()} denies access to the package
1795      *             of this class
1796      *
1797      *             &lt;/ul&gt;
1798      *
1799      * @since JDK1.1
1800      */
1801     public Method[] getDeclaredMethods() throws SecurityException {
1802         // be very careful not to change the stack depth of this
1803         // checkMemberAccess call for security reasons
1804         // see java.lang.SecurityManager.checkMemberAccess
1805         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
1806         return copyMethods(privateGetDeclaredMethods(false));
1807     }
1808 
1809 
1810     /**
1811      * Returns an array of {@code Constructor} objects reflecting all the
1812      * constructors declared by the class represented by this
1813      * {@code Class} object. These are public, protected, default
1814      * (package) access, and private constructors.  The elements in the array
1815      * returned are not sorted and are not in any particular order.  If the
1816      * class has a default constructor, it is included in the returned array.
1817      * This method returns an array of length 0 if this {@code Class}
1818      * object represents an interface, a primitive type, an array class, or
1819      * void.
1820      *
1821      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.
1822      *
1823      * @return    the array of {@code Constructor} objects representing all the
1824      * declared constructors of this class
1825      * @exception  SecurityException
1826      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1827      *             following conditions is met:
1828      *
1829      *             &lt;ul&gt;
1830      *
1831      *             &lt;li&gt; invocation of
1832      *             {@link SecurityManager#checkMemberAccess
1833      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1834      *             access to the declared constructors within this class
1835      *
1836      *             &lt;li&gt; the caller's class loader is not the same as or an
1837      *             ancestor of the class loader for the current class and
1838      *             invocation of {@link SecurityManager#checkPackageAccess
1839      *             s.checkPackageAccess()} denies access to the package
1840      *             of this class
1841      *
1842      *             &lt;/ul&gt;
1843      *
1844      * @since JDK1.1
1845      */
1846     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
1847         // be very careful not to change the stack depth of this
1848         // checkMemberAccess call for security reasons
1849         // see java.lang.SecurityManager.checkMemberAccess
1850         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
1851         return copyConstructors(privateGetDeclaredConstructors(false));
1852     }
1853 
1854 
1855     /**
1856      * Returns a {@code Field} object that reflects the specified declared
1857      * field of the class or interface represented by this {@code Class}
1858      * object. The {@code name} parameter is a {@code String} that
1859      * specifies the simple name of the desired field.  Note that this method
1860      * will not reflect the {@code length} field of an array class.
1861      *
1862      * @param name the name of the field
1863      * @return the {@code Field} object for the specified field in this
1864      * class
1865      * @exception NoSuchFieldException if a field with the specified name is
1866      *              not found.
1867      * @exception NullPointerException if {@code name} is {@code null}
1868      * @exception  SecurityException
1869      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1870      *             following conditions is met:
1871      *
1872      *             &lt;ul&gt;
1873      *
1874      *             &lt;li&gt; invocation of
1875      *             {@link SecurityManager#checkMemberAccess
1876      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1877      *             access to the declared field
1878      *
1879      *             &lt;li&gt; the caller's class loader is not the same as or an
1880      *             ancestor of the class loader for the current class and
1881      *             invocation of {@link SecurityManager#checkPackageAccess
1882      *             s.checkPackageAccess()} denies access to the package
1883      *             of this class
1884      *
1885      *             &lt;/ul&gt;
1886      *
1887      * @since JDK1.1
1888      */
1889     public Field getDeclaredField(String name)
1890         throws NoSuchFieldException, SecurityException {
1891         // be very careful not to change the stack depth of this
1892         // checkMemberAccess call for security reasons
1893         // see java.lang.SecurityManager.checkMemberAccess
1894         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
1895         Field field = searchFields(privateGetDeclaredFields(false), name);
1896         if (field == null) {
1897             throw new NoSuchFieldException(name);
1898         }
1899         return field;
1900     }
1901 
1902 
1903     /**
1904      * Returns a {@code Method} object that reflects the specified
1905      * declared method of the class or interface represented by this
1906      * {@code Class} object. The {@code name} parameter is a
1907      * {@code String} that specifies the simple name of the desired
1908      * method, and the {@code parameterTypes} parameter is an array of
1909      * {@code Class} objects that identify the method's formal parameter
1910      * types, in declared order.  If more than one method with the same
1911      * parameter types is declared in a class, and one of these methods has a
1912      * return type that is more specific than any of the others, that method is
1913      * returned; otherwise one of the methods is chosen arbitrarily.  If the
1914      * name is "&amp;lt;init&amp;gt;"or "&amp;lt;clinit&amp;gt;" a {@code NoSuchMethodException}
1915      * is raised.
1916      *
1917      * @param name the name of the method
1918      * @param parameterTypes the parameter array
1919      * @return    the {@code Method} object for the method of this class
1920      * matching the specified name and parameters
1921      * @exception NoSuchMethodException if a matching method is not found.
1922      * @exception NullPointerException if {@code name} is {@code null}
1923      * @exception  SecurityException
1924      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1925      *             following conditions is met:
1926      *
1927      *             &lt;ul&gt;
1928      *
1929      *             &lt;li&gt; invocation of
1930      *             {@link SecurityManager#checkMemberAccess
1931      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1932      *             access to the declared method
1933      *
1934      *             &lt;li&gt; the caller's class loader is not the same as or an
1935      *             ancestor of the class loader for the current class and
1936      *             invocation of {@link SecurityManager#checkPackageAccess
1937      *             s.checkPackageAccess()} denies access to the package
1938      *             of this class
1939      *
1940      *             &lt;/ul&gt;
1941      *
1942      * @since JDK1.1
1943      */
1944     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
1945         throws NoSuchMethodException, SecurityException {
1946         // be very careful not to change the stack depth of this
1947         // checkMemberAccess call for security reasons
1948         // see java.lang.SecurityManager.checkMemberAccess
1949         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
1950         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
1951         if (method == null) {
1952             throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
1953         }
1954         return method;
1955     }
1956 
1957 
1958     /**
1959      * Returns a {@code Constructor} object that reflects the specified
1960      * constructor of the class or interface represented by this
1961      * {@code Class} object.  The {@code parameterTypes} parameter is
1962      * an array of {@code Class} objects that identify the constructor's
1963      * formal parameter types, in declared order.
1964      *
1965      * If this {@code Class} object represents an inner class
1966      * declared in a non-static context, the formal parameter types
1967      * include the explicit enclosing instance as the first parameter.
1968      *
1969      * @param parameterTypes the parameter array
1970      * @return    The {@code Constructor} object for the constructor with the
1971      * specified parameter list
1972      * @exception NoSuchMethodException if a matching method is not found.
1973      * @exception  SecurityException
1974      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1975      *             following conditions is met:
1976      *
1977      *             &lt;ul&gt;
1978      *
1979      *             &lt;li&gt; invocation of
1980      *             {@link SecurityManager#checkMemberAccess
1981      *             s.checkMemberAccess(this, Member.DECLARED)} denies
1982      *             access to the declared constructor
1983      *
1984      *             &lt;li&gt; the caller's class loader is not the same as or an
1985      *             ancestor of the class loader for the current class and
1986      *             invocation of {@link SecurityManager#checkPackageAccess
1987      *             s.checkPackageAccess()} denies access to the package
1988      *             of this class
1989      *
1990      *             &lt;/ul&gt;
1991      *
1992      * @since JDK1.1
1993      */
1994     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
1995         throws NoSuchMethodException, SecurityException {
1996         // be very careful not to change the stack depth of this
1997         // checkMemberAccess call for security reasons
1998         // see java.lang.SecurityManager.checkMemberAccess
1999         checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
2000         return getConstructor0(parameterTypes, Member.DECLARED);
2001     }
2002 
2003     /**
2004      * Finds a resource with a given name.  The rules for searching resources
2005      * associated with a given class are implemented by the defining
2006      * {@linkplain ClassLoader class loader} of the class.  This method
2007      * delegates to this object's class loader.  If this object was loaded by
2008      * the bootstrap class loader, the method delegates to {@link
2009      * ClassLoader#getSystemResourceAsStream}.
2010      *
2011      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2012      * given resource name using this algorithm:
2013      *
2014      * &lt;ul&gt;
2015      *
2016      * &lt;li&gt; If the {@code name} begins with a {@code '/'}
2017      * (&lt;tt&gt;'&amp;#92;u002f'&lt;/tt&gt;), then the absolute name of the resource is the
2018      * portion of the {@code name} following the {@code '/'}.
2019      *
2020      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2021      *
2022      * &lt;blockquote&gt;
2023      *   {@code modified_package_name/name}
2024      * &lt;/blockquote&gt;
2025      *
2026      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2027      * object with {@code '/'} substituted for {@code '.'}
2028      * (&lt;tt&gt;'&amp;#92;u002e'&lt;/tt&gt;).
2029      *
2030      * &lt;/ul&gt;
2031      *
2032      * @param  name name of the desired resource
2033      * @return      A {@link java.io.InputStream} object or {@code null} if
2034      *              no resource with this name is found
2035      * @throws  NullPointerException If {@code name} is {@code null}
2036      * @since  JDK1.1
2037      */
2038      public InputStream getResourceAsStream(String name) {
2039         name = resolveName(name);
2040         ClassLoader cl = getClassLoader0();
2041         if (cl==null) {
2042             // A system class.
2043             return ClassLoader.getSystemResourceAsStream(name);
2044         }
2045         return cl.getResourceAsStream(name);
2046     }
2047 
2048     /**
2049      * Finds a resource with a given name.  The rules for searching resources
2050      * associated with a given class are implemented by the defining
2051      * {@linkplain ClassLoader class loader} of the class.  This method
2052      * delegates to this object's class loader.  If this object was loaded by
2053      * the bootstrap class loader, the method delegates to {@link
2054      * ClassLoader#getSystemResource}.
2055      *
2056      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2057      * given resource name using this algorithm:
2058      *
2059      * &lt;ul&gt;
2060      *
2061      * &lt;li&gt; If the {@code name} begins with a {@code '/'}
2062      * (&lt;tt&gt;'&amp;#92;u002f'&lt;/tt&gt;), then the absolute name of the resource is the
2063      * portion of the {@code name} following the {@code '/'}.
2064      *
2065      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2066      *
2067      * &lt;blockquote&gt;
2068      *   {@code modified_package_name/name}
2069      * &lt;/blockquote&gt;
2070      *
2071      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2072      * object with {@code '/'} substituted for {@code '.'}
2073      * (&lt;tt&gt;'&amp;#92;u002e'&lt;/tt&gt;).
2074      *
2075      * &lt;/ul&gt;
2076      *
2077      * @param  name name of the desired resource
2078      * @return      A  {@link java.net.URL} object or {@code null} if no
2079      *              resource with this name is found
2080      * @since  JDK1.1
2081      */
2082     public java.net.URL getResource(String name) {
2083         name = resolveName(name);
2084         ClassLoader cl = getClassLoader0();
2085         if (cl==null) {
2086             // A system class.
2087             return ClassLoader.getSystemResource(name);
2088         }
2089         return cl.getResource(name);
2090     }
2091 
2092 
2093 
2094     /** protection domain returned when the internal domain is null */
2095     private static java.security.ProtectionDomain allPermDomain;
2096 
2097 
2098     /**
2099      * Returns the {@code ProtectionDomain} of this class.  If there is a
2100      * security manager installed, this method first calls the security
2101      * manager's {@code checkPermission} method with a
2102      * {@code RuntimePermission("getProtectionDomain")} permission to
2103      * ensure it's ok to get the
2104      * {@code ProtectionDomain}.
2105      *
2106      * @return the ProtectionDomain of this class
2107      *
2108      * @throws SecurityException
2109      *        if a security manager exists and its
2110      *        {@code checkPermission} method doesn't allow
2111      *        getting the ProtectionDomain.
2112      *
2113      * @see java.security.ProtectionDomain
2114      * @see SecurityManager#checkPermission
2115      * @see java.lang.RuntimePermission
2116      * @since 1.2
2117      */
2118     public java.security.ProtectionDomain getProtectionDomain() {
2119         SecurityManager sm = System.getSecurityManager();
2120         if (sm != null) {
2121             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2122         }
2123         java.security.ProtectionDomain pd = getProtectionDomain0();
2124         if (pd == null) {
2125             if (allPermDomain == null) {
2126                 java.security.Permissions perms =
2127                     new java.security.Permissions();
2128                 perms.add(SecurityConstants.ALL_PERMISSION);
2129                 allPermDomain =
2130                     new java.security.ProtectionDomain(null, perms);
2131             }
2132             pd = allPermDomain;
2133         }
2134         return pd;
2135     }
2136 
2137 
2138     /**
2139      * Returns the ProtectionDomain of this class.
2140      */
2141     private native java.security.ProtectionDomain getProtectionDomain0();
2142 
2143 
2144     /**
2145      * Set the ProtectionDomain for this class. Called by
2146      * ClassLoader.defineClass.
2147      */
2148     native void setProtectionDomain0(java.security.ProtectionDomain pd);
2149 
2150 
2151     /*
2152      * Return the Virtual Machine's Class object for the named
2153      * primitive type.
2154      */
2155     static native Class&lt;?&gt; getPrimitiveClass(String name);
2156 
2157 
2158     /*
2159      * Check if client is allowed to access members.  If access is denied,
2160      * throw a SecurityException.
2161      *
2162      * Be very careful not to change the stack depth of this checkMemberAccess
2163      * call for security reasons.
2164      * See java.lang.SecurityManager.checkMemberAccess.
2165      *
2166      * &lt;p&gt; Default policy: allow all clients access with normal Java access
2167      * control.
2168      */
2169     private void checkMemberAccess(int which, ClassLoader ccl) {
2170         SecurityManager s = System.getSecurityManager();
2171         if (s != null) {
2172             s.checkMemberAccess(this, which);
2173             ClassLoader cl = getClassLoader0();
2174             if (sun.reflect.misc.ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
2175                 String name = this.getName();
2176                 int i = name.lastIndexOf('.');
2177                 if (i != -1) {
2178                     s.checkPackageAccess(name.substring(0, i));
2179                 }
2180             }
2181         }
2182     }
2183 
2184     /**
2185      * Add a package name prefix if the name is not absolute Remove leading "/"
2186      * if name is absolute
2187      */
2188     private String resolveName(String name) {
2189         if (name == null) {
2190             return name;
2191         }
2192         if (!name.startsWith("/")) {
2193             Class&lt;?&gt; c = this;
2194             while (c.isArray()) {
2195                 c = c.getComponentType();
2196             }
2197             String baseName = c.getName();
2198             int index = baseName.lastIndexOf('.');
2199             if (index != -1) {
2200                 name = baseName.substring(0, index).replace('.', '/')
2201                     +"/"+name;
2202             }
2203         } else {
2204             name = name.substring(1);
2205         }
2206         return name;
2207     }
2208 
2209     /**
2210      * Reflection support.
2211      */
2212 
2213     // Caches for certain reflective results
2214     private static boolean useCaches = true;
<a name="2" id="anc2"></a><span class="changed">2215     private volatile transient SoftReference&lt;Field[]&gt; declaredFields;</span>
<span class="changed">2216     private volatile transient SoftReference&lt;Field[]&gt; publicFields;</span>
<span class="changed">2217     private volatile transient SoftReference&lt;Method[]&gt; declaredMethods;</span>
<span class="changed">2218     private volatile transient SoftReference&lt;Method[]&gt; publicMethods;</span>
<span class="changed">2219     private volatile transient SoftReference&lt;Constructor&lt;T&gt;[]&gt; declaredConstructors;</span>
<span class="changed">2220     private volatile transient SoftReference&lt;Constructor&lt;T&gt;[]&gt; publicConstructors;</span>



2221     // Intermediate results for getFields and getMethods
<a name="3" id="anc3"></a><span class="changed">2222     private volatile transient SoftReference&lt;Field[]&gt; declaredPublicFields;</span>
<span class="changed">2223     private volatile transient SoftReference&lt;Method[]&gt; declaredPublicMethods;</span>






























2224 
2225     // Incremented by the VM on each call to JVM TI RedefineClasses()
2226     // that redefines this class or a superclass.
2227     private volatile transient int classRedefinedCount = 0;
2228 
<a name="4" id="anc4"></a><span class="changed">2229     // Value of classRedefinedCount when we last cleared the cached values</span>
<span class="changed">2230     // that are sensitive to class redefinition.</span>
<span class="changed">2231     private volatile transient int lastRedefinedCount = 0;</span>
<span class="changed">2232 </span>
<span class="changed">2233     // Clears cached values that might possibly have been obsoleted by</span>
<span class="changed">2234     // a class redefinition.</span>
<span class="changed">2235     private void clearCachesOnClassRedefinition() {</span>
<span class="changed">2236         if (lastRedefinedCount != classRedefinedCount) {</span>
<span class="changed">2237             declaredFields = publicFields = declaredPublicFields = null;</span>
<span class="changed">2238             declaredMethods = publicMethods = declaredPublicMethods = null;</span>
<span class="changed">2239             declaredConstructors = publicConstructors = null;</span>
<span class="changed">2240             annotations = declaredAnnotations = null;</span>
<span class="changed">2241 </span>
<span class="changed">2242             // Use of "volatile" (and synchronization by caller in the case</span>
<span class="changed">2243             // of annotations) ensures that no thread sees the update to</span>
<span class="changed">2244             // lastRedefinedCount before seeing the caches cleared.</span>
<span class="changed">2245             // We do not guard against brief windows during which multiple</span>
<span class="changed">2246             // threads might redundantly work to fill an empty cache.</span>
<span class="changed">2247             lastRedefinedCount = classRedefinedCount;</span>
2248         }
2249     }
2250 
2251     // Generic signature handling
2252     private native String getGenericSignature();
2253 
2254     // Generic info repository; lazily initialized
2255     private transient ClassRepository genericInfo;
2256 
2257     // accessor for factory
2258     private GenericsFactory getFactory() {
2259         // create scope and factory
2260         return CoreReflectionFactory.make(this, ClassScope.make(this));
2261     }
2262 
2263     // accessor for generic info repository
2264     private ClassRepository getGenericInfo() {
2265         // lazily initialize repository if necessary
2266         if (genericInfo == null) {
2267             // create and cache generic info repository
2268             genericInfo = ClassRepository.make(getGenericSignature(),
2269                                                getFactory());
2270         }
2271         return genericInfo; //return cached repository
2272     }
2273 
2274     // Annotations handling
2275     private native byte[] getRawAnnotations();
2276 
2277     native ConstantPool getConstantPool();
2278 
2279     //
2280     //
2281     // java.lang.reflect.Field handling
2282     //
2283     //
2284 
2285     // Returns an array of "root" fields. These Field objects must NOT
2286     // be propagated to the outside world, but must instead be copied
2287     // via ReflectionFactory.copyField.
2288     private Field[] privateGetDeclaredFields(boolean publicOnly) {
2289         checkInitted();
2290         Field[] res = null;
<a name="5" id="anc5"></a><span class="changed">2291         if (useCaches) {</span>
<span class="changed">2292             clearCachesOnClassRedefinition();</span>
<span class="changed">2293             if (publicOnly) {</span>
<span class="changed">2294                 if (declaredPublicFields != null) {</span>
<span class="changed">2295                     res = declaredPublicFields.get();</span>
<span class="changed">2296                 }</span>
<span class="changed">2297             } else {</span>
<span class="changed">2298                 if (declaredFields != null) {</span>
<span class="changed">2299                     res = declaredFields.get();</span>
<span class="changed">2300                 }</span>
<span class="changed">2301             }</span>
2302             if (res != null) return res;
2303         }
2304         // No cached value available; request value from VM
2305         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
<a name="6" id="anc6"></a><span class="changed">2306         if (useCaches) {</span>
2307             if (publicOnly) {
<a name="7" id="anc7"></a><span class="changed">2308                 declaredPublicFields = new SoftReference&lt;&gt;(res);</span>
2309             } else {
<a name="8" id="anc8"></a><span class="changed">2310                 declaredFields = new SoftReference&lt;&gt;(res);</span>
2311             }
2312         }
2313         return res;
2314     }
2315 
2316     // Returns an array of "root" fields. These Field objects must NOT
2317     // be propagated to the outside world, but must instead be copied
2318     // via ReflectionFactory.copyField.
2319     private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {
2320         checkInitted();
2321         Field[] res = null;
<a name="9" id="anc9"></a><span class="changed">2322         if (useCaches) {</span>
<span class="changed">2323             clearCachesOnClassRedefinition();</span>
<span class="changed">2324             if (publicFields != null) {</span>
<span class="changed">2325                 res = publicFields.get();</span>
<span class="changed">2326             }</span>
2327             if (res != null) return res;
2328         }
2329 
2330         // No cached value available; compute value recursively.
2331         // Traverse in correct order for getField().
2332         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
2333         if (traversedInterfaces == null) {
2334             traversedInterfaces = new HashSet&lt;&gt;();
2335         }
2336 
2337         // Local fields
2338         Field[] tmp = privateGetDeclaredFields(true);
2339         addAll(fields, tmp);
2340 
2341         // Direct superinterfaces, recursively
2342         for (Class&lt;?&gt; c : getInterfaces()) {
2343             if (!traversedInterfaces.contains(c)) {
2344                 traversedInterfaces.add(c);
2345                 addAll(fields, c.privateGetPublicFields(traversedInterfaces));
2346             }
2347         }
2348 
2349         // Direct superclass, recursively
2350         if (!isInterface()) {
2351             Class&lt;?&gt; c = getSuperclass();
2352             if (c != null) {
2353                 addAll(fields, c.privateGetPublicFields(traversedInterfaces));
2354             }
2355         }
2356 
2357         res = new Field[fields.size()];
2358         fields.toArray(res);
<a name="10" id="anc10"></a><span class="changed">2359         if (useCaches) {</span>
<span class="changed">2360             publicFields = new SoftReference&lt;&gt;(res);</span>
2361         }
2362         return res;
2363     }
2364 
2365     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
2366         for (int i = 0; i &lt; o.length; i++) {
2367             c.add(o[i]);
2368         }
2369     }
2370 
2371 
2372     //
2373     //
2374     // java.lang.reflect.Constructor handling
2375     //
2376     //
2377 
2378     // Returns an array of "root" constructors. These Constructor
2379     // objects must NOT be propagated to the outside world, but must
2380     // instead be copied via ReflectionFactory.copyConstructor.
2381     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
2382         checkInitted();
2383         Constructor&lt;T&gt;[] res = null;
<a name="11" id="anc11"></a><span class="changed">2384         if (useCaches) {</span>
<span class="changed">2385             clearCachesOnClassRedefinition();</span>
<span class="changed">2386             if (publicOnly) {</span>
<span class="changed">2387                 if (publicConstructors != null) {</span>
<span class="changed">2388                     res = publicConstructors.get();</span>
<span class="changed">2389                 }</span>
<span class="changed">2390             } else {</span>
<span class="changed">2391                 if (declaredConstructors != null) {</span>
<span class="changed">2392                     res = declaredConstructors.get();</span>
<span class="changed">2393                 }</span>
<span class="changed">2394             }</span>
2395             if (res != null) return res;
2396         }
2397         // No cached value available; request value from VM
2398         if (isInterface()) {
2399             @SuppressWarnings("unchecked")
2400             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
2401             res = temporaryRes;
2402         } else {
2403             res = getDeclaredConstructors0(publicOnly);
2404         }
<a name="12" id="anc12"></a><span class="changed">2405         if (useCaches) {</span>
2406             if (publicOnly) {
<a name="13" id="anc13"></a><span class="changed">2407                 publicConstructors = new SoftReference&lt;&gt;(res);</span>
2408             } else {
<a name="14" id="anc14"></a><span class="changed">2409                 declaredConstructors = new SoftReference&lt;&gt;(res);</span>
2410             }
2411         }
2412         return res;
2413     }
2414 
2415     //
2416     //
2417     // java.lang.reflect.Method handling
2418     //
2419     //
2420 
2421     // Returns an array of "root" methods. These Method objects must NOT
2422     // be propagated to the outside world, but must instead be copied
2423     // via ReflectionFactory.copyMethod.
2424     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
2425         checkInitted();
2426         Method[] res = null;
<a name="15" id="anc15"></a><span class="changed">2427         if (useCaches) {</span>
<span class="changed">2428             clearCachesOnClassRedefinition();</span>
<span class="changed">2429             if (publicOnly) {</span>
<span class="changed">2430                 if (declaredPublicMethods != null) {</span>
<span class="changed">2431                     res = declaredPublicMethods.get();</span>
<span class="changed">2432                 }</span>
<span class="changed">2433             } else {</span>
<span class="changed">2434                 if (declaredMethods != null) {</span>
<span class="changed">2435                     res = declaredMethods.get();</span>
<span class="changed">2436                 }</span>
<span class="changed">2437             }</span>
2438             if (res != null) return res;
2439         }
2440         // No cached value available; request value from VM
2441         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
2442         if (useCaches) {
2443             if (publicOnly) {
<a name="16" id="anc16"></a><span class="changed">2444                 declaredPublicMethods = new SoftReference&lt;&gt;(res);</span>
2445             } else {
<a name="17" id="anc17"></a><span class="changed">2446                 declaredMethods = new SoftReference&lt;&gt;(res);</span>
2447             }
2448         }
2449         return res;
2450     }
2451 
2452     static class MethodArray {
2453         private Method[] methods;
2454         private int length;
2455 
2456         MethodArray() {
2457             methods = new Method[20];
2458             length = 0;
2459         }
2460 
2461         void add(Method m) {
2462             if (length == methods.length) {
2463                 methods = Arrays.copyOf(methods, 2 * methods.length);
2464             }
2465             methods[length++] = m;
2466         }
2467 
2468         void addAll(Method[] ma) {
2469             for (int i = 0; i &lt; ma.length; i++) {
2470                 add(ma[i]);
2471             }
2472         }
2473 
2474         void addAll(MethodArray ma) {
2475             for (int i = 0; i &lt; ma.length(); i++) {
2476                 add(ma.get(i));
2477             }
2478         }
2479 
2480         void addIfNotPresent(Method newMethod) {
2481             for (int i = 0; i &lt; length; i++) {
2482                 Method m = methods[i];
2483                 if (m == newMethod || (m != null &amp;&amp; m.equals(newMethod))) {
2484                     return;
2485                 }
2486             }
2487             add(newMethod);
2488         }
2489 
2490         void addAllIfNotPresent(MethodArray newMethods) {
2491             for (int i = 0; i &lt; newMethods.length(); i++) {
2492                 Method m = newMethods.get(i);
2493                 if (m != null) {
2494                     addIfNotPresent(m);
2495                 }
2496             }
2497         }
2498 
2499         int length() {
2500             return length;
2501         }
2502 
2503         Method get(int i) {
2504             return methods[i];
2505         }
2506 
2507         void removeByNameAndSignature(Method toRemove) {
2508             for (int i = 0; i &lt; length; i++) {
2509                 Method m = methods[i];
2510                 if (m != null &amp;&amp;
2511                     m.getReturnType() == toRemove.getReturnType() &amp;&amp;
2512                     m.getName() == toRemove.getName() &amp;&amp;
2513                     arrayContentsEq(m.getParameterTypes(),
2514                                     toRemove.getParameterTypes())) {
2515                     methods[i] = null;
2516                 }
2517             }
2518         }
2519 
2520         void compactAndTrim() {
2521             int newPos = 0;
2522             // Get rid of null slots
2523             for (int pos = 0; pos &lt; length; pos++) {
2524                 Method m = methods[pos];
2525                 if (m != null) {
2526                     if (pos != newPos) {
2527                         methods[newPos] = m;
2528                     }
2529                     newPos++;
2530                 }
2531             }
2532             if (newPos != methods.length) {
2533                 methods = Arrays.copyOf(methods, newPos);
2534             }
2535         }
2536 
2537         Method[] getArray() {
2538             return methods;
2539         }
2540     }
2541 
2542 
2543     // Returns an array of "root" methods. These Method objects must NOT
2544     // be propagated to the outside world, but must instead be copied
2545     // via ReflectionFactory.copyMethod.
2546     private Method[] privateGetPublicMethods() {
2547         checkInitted();
2548         Method[] res = null;
<a name="18" id="anc18"></a><span class="changed">2549         if (useCaches) {</span>
<span class="changed">2550             clearCachesOnClassRedefinition();</span>
<span class="changed">2551             if (publicMethods != null) {</span>
<span class="changed">2552                 res = publicMethods.get();</span>
<span class="changed">2553             }</span>
2554             if (res != null) return res;
2555         }
2556 
2557         // No cached value available; compute value recursively.
2558         // Start by fetching public declared methods
2559         MethodArray methods = new MethodArray();
2560         {
2561                 Method[] tmp = privateGetDeclaredMethods(true);
2562             methods.addAll(tmp);
2563         }
2564         // Now recur over superclass and direct superinterfaces.
2565         // Go over superinterfaces first so we can more easily filter
2566         // out concrete implementations inherited from superclasses at
2567         // the end.
2568         MethodArray inheritedMethods = new MethodArray();
2569         Class&lt;?&gt;[] interfaces = getInterfaces();
2570         for (int i = 0; i &lt; interfaces.length; i++) {
2571             inheritedMethods.addAll(interfaces[i].privateGetPublicMethods());
2572         }
2573         if (!isInterface()) {
2574             Class&lt;?&gt; c = getSuperclass();
2575             if (c != null) {
2576                 MethodArray supers = new MethodArray();
2577                 supers.addAll(c.privateGetPublicMethods());
2578                 // Filter out concrete implementations of any
2579                 // interface methods
2580                 for (int i = 0; i &lt; supers.length(); i++) {
2581                     Method m = supers.get(i);
2582                     if (m != null &amp;&amp; !Modifier.isAbstract(m.getModifiers())) {
2583                         inheritedMethods.removeByNameAndSignature(m);
2584                     }
2585                 }
2586                 // Insert superclass's inherited methods before
2587                 // superinterfaces' to satisfy getMethod's search
2588                 // order
2589                 supers.addAll(inheritedMethods);
2590                 inheritedMethods = supers;
2591             }
2592         }
2593         // Filter out all local methods from inherited ones
2594         for (int i = 0; i &lt; methods.length(); i++) {
2595             Method m = methods.get(i);
2596             inheritedMethods.removeByNameAndSignature(m);
2597         }
2598         methods.addAllIfNotPresent(inheritedMethods);
2599         methods.compactAndTrim();
2600         res = methods.getArray();
<a name="19" id="anc19"></a><span class="changed">2601         if (useCaches) {</span>
<span class="changed">2602             publicMethods = new SoftReference&lt;&gt;(res);</span>
2603         }
2604         return res;
2605     }
2606 
2607 
2608     //
2609     // Helpers for fetchers of one field, method, or constructor
2610     //
2611 
<a name="20" id="anc20"></a><span class="changed">2612     private Field searchFields(Field[] fields, String name) {</span>
2613         String internedName = name.intern();
2614         for (int i = 0; i &lt; fields.length; i++) {
2615             if (fields[i].getName() == internedName) {
2616                 return getReflectionFactory().copyField(fields[i]);
2617             }
2618         }
2619         return null;
2620     }
2621 
2622     private Field getField0(String name) throws NoSuchFieldException {
2623         // Note: the intent is that the search algorithm this routine
2624         // uses be equivalent to the ordering imposed by
2625         // privateGetPublicFields(). It fetches only the declared
2626         // public fields for each class, however, to reduce the number
2627         // of Field objects which have to be created for the common
2628         // case where the field being requested is declared in the
2629         // class which is being queried.
2630         Field res = null;
2631         // Search declared public fields
2632         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
2633             return res;
2634         }
2635         // Direct superinterfaces, recursively
2636         Class&lt;?&gt;[] interfaces = getInterfaces();
2637         for (int i = 0; i &lt; interfaces.length; i++) {
2638             Class&lt;?&gt; c = interfaces[i];
2639             if ((res = c.getField0(name)) != null) {
2640                 return res;
2641             }
2642         }
2643         // Direct superclass, recursively
2644         if (!isInterface()) {
2645             Class&lt;?&gt; c = getSuperclass();
2646             if (c != null) {
2647                 if ((res = c.getField0(name)) != null) {
2648                     return res;
2649                 }
2650             }
2651         }
2652         return null;
2653     }
2654 
2655     private static Method searchMethods(Method[] methods,
2656                                         String name,
2657                                         Class&lt;?&gt;[] parameterTypes)
2658     {
2659         Method res = null;
2660         String internedName = name.intern();
2661         for (int i = 0; i &lt; methods.length; i++) {
2662             Method m = methods[i];
2663             if (m.getName() == internedName
2664                 &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())
2665                 &amp;&amp; (res == null
2666                     || res.getReturnType().isAssignableFrom(m.getReturnType())))
2667                 res = m;
2668         }
2669 
2670         return (res == null ? res : getReflectionFactory().copyMethod(res));
2671     }
2672 
2673 
2674     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
2675         // Note: the intent is that the search algorithm this routine
2676         // uses be equivalent to the ordering imposed by
2677         // privateGetPublicMethods(). It fetches only the declared
2678         // public methods for each class, however, to reduce the
2679         // number of Method objects which have to be created for the
2680         // common case where the method being requested is declared in
2681         // the class which is being queried.
2682         Method res = null;
2683         // Search declared public methods
2684         if ((res = searchMethods(privateGetDeclaredMethods(true),
2685                                  name,
2686                                  parameterTypes)) != null) {
2687             return res;
2688         }
2689         // Search superclass's methods
2690         if (!isInterface()) {
2691             Class&lt;? super T&gt; c = getSuperclass();
2692             if (c != null) {
2693                 if ((res = c.getMethod0(name, parameterTypes)) != null) {
2694                     return res;
2695                 }
2696             }
2697         }
2698         // Search superinterfaces' methods
2699         Class&lt;?&gt;[] interfaces = getInterfaces();
2700         for (int i = 0; i &lt; interfaces.length; i++) {
2701             Class&lt;?&gt; c = interfaces[i];
2702             if ((res = c.getMethod0(name, parameterTypes)) != null) {
2703                 return res;
2704             }
2705         }
2706         // Not found
2707         return null;
2708     }
2709 
2710     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
2711                                         int which) throws NoSuchMethodException
2712     {
2713         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
2714         for (Constructor&lt;T&gt; constructor : constructors) {
2715             if (arrayContentsEq(parameterTypes,
2716                                 constructor.getParameterTypes())) {
2717                 return getReflectionFactory().copyConstructor(constructor);
2718             }
2719         }
2720         throw new NoSuchMethodException(getName() + ".&lt;init&gt;" + argumentTypesToString(parameterTypes));
2721     }
2722 
2723     //
2724     // Other helpers and base implementation
2725     //
2726 
2727     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
2728         if (a1 == null) {
2729             return a2 == null || a2.length == 0;
2730         }
2731 
2732         if (a2 == null) {
2733             return a1.length == 0;
2734         }
2735 
2736         if (a1.length != a2.length) {
2737             return false;
2738         }
2739 
2740         for (int i = 0; i &lt; a1.length; i++) {
2741             if (a1[i] != a2[i]) {
2742                 return false;
2743             }
2744         }
2745 
2746         return true;
2747     }
2748 
2749     private static Field[] copyFields(Field[] arg) {
2750         Field[] out = new Field[arg.length];
2751         ReflectionFactory fact = getReflectionFactory();
2752         for (int i = 0; i &lt; arg.length; i++) {
2753             out[i] = fact.copyField(arg[i]);
2754         }
2755         return out;
2756     }
2757 
2758     private static Method[] copyMethods(Method[] arg) {
2759         Method[] out = new Method[arg.length];
2760         ReflectionFactory fact = getReflectionFactory();
2761         for (int i = 0; i &lt; arg.length; i++) {
2762             out[i] = fact.copyMethod(arg[i]);
2763         }
2764         return out;
2765     }
2766 
2767     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
2768         Constructor&lt;U&gt;[] out = arg.clone();
2769         ReflectionFactory fact = getReflectionFactory();
2770         for (int i = 0; i &lt; out.length; i++) {
2771             out[i] = fact.copyConstructor(out[i]);
2772         }
2773         return out;
2774     }
2775 
2776     private native Field[]       getDeclaredFields0(boolean publicOnly);
2777     private native Method[]      getDeclaredMethods0(boolean publicOnly);
2778     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
2779     private native Class&lt;?&gt;[]   getDeclaredClasses0();
2780 
2781     private static String        argumentTypesToString(Class&lt;?&gt;[] argTypes) {
2782         StringBuilder buf = new StringBuilder();
2783         buf.append("(");
2784         if (argTypes != null) {
2785             for (int i = 0; i &lt; argTypes.length; i++) {
2786                 if (i &gt; 0) {
2787                     buf.append(", ");
2788                 }
2789                 Class&lt;?&gt; c = argTypes[i];
2790                 buf.append((c == null) ? "null" : c.getName());
2791             }
2792         }
2793         buf.append(")");
2794         return buf.toString();
2795     }
2796 
2797     /** use serialVersionUID from JDK 1.1 for interoperability */
2798     private static final long serialVersionUID = 3206093459760846163L;
2799 
2800 
2801     /**
2802      * Class Class is special cased within the Serialization Stream Protocol.
2803      *
2804      * A Class instance is written initially into an ObjectOutputStream in the
2805      * following format:
2806      * &lt;pre&gt;
2807      *      {@code TC_CLASS} ClassDescriptor
2808      *      A ClassDescriptor is a special cased serialization of
2809      *      a {@code java.io.ObjectStreamClass} instance.
2810      * &lt;/pre&gt;
2811      * A new handle is generated for the initial time the class descriptor
2812      * is written into the stream. Future references to the class descriptor
2813      * are written as references to the initial class descriptor instance.
2814      *
2815      * @see java.io.ObjectStreamClass
2816      */
2817     private static final ObjectStreamField[] serialPersistentFields =
2818         new ObjectStreamField[0];
2819 
2820 
2821     /**
2822      * Returns the assertion status that would be assigned to this
2823      * class if it were to be initialized at the time this method is invoked.
2824      * If this class has had its assertion status set, the most recent
2825      * setting will be returned; otherwise, if any package default assertion
2826      * status pertains to this class, the most recent setting for the most
2827      * specific pertinent package default assertion status is returned;
2828      * otherwise, if this class is not a system class (i.e., it has a
2829      * class loader) its class loader's default assertion status is returned;
2830      * otherwise, the system class default assertion status is returned.
2831      * &lt;p&gt;
2832      * Few programmers will have any need for this method; it is provided
2833      * for the benefit of the JRE itself.  (It allows a class to determine at
2834      * the time that it is initialized whether assertions should be enabled.)
2835      * Note that this method is not guaranteed to return the actual
2836      * assertion status that was (or will be) associated with the specified
2837      * class when it was (or will be) initialized.
2838      *
2839      * @return the desired assertion status of the specified class.
2840      * @see    java.lang.ClassLoader#setClassAssertionStatus
2841      * @see    java.lang.ClassLoader#setPackageAssertionStatus
2842      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
2843      * @since  1.4
2844      */
2845     public boolean desiredAssertionStatus() {
2846         ClassLoader loader = getClassLoader();
2847         // If the loader is null this is a system class, so ask the VM
2848         if (loader == null)
2849             return desiredAssertionStatus0(this);
2850 
2851         // If the classloader has been initialized with the assertion
2852         // directives, ask it. Otherwise, ask the VM.
2853         synchronized(loader.assertionLock) {
2854             if (loader.classAssertionStatus != null) {
2855                 return loader.desiredAssertionStatus(getName());
2856             }
2857         }
2858         return desiredAssertionStatus0(this);
2859     }
2860 
2861     // Retrieves the desired assertion status of this class from the VM
2862     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
2863 
2864     /**
2865      * Returns true if and only if this class was declared as an enum in the
2866      * source code.
2867      *
2868      * @return true if and only if this class was declared as an enum in the
2869      *     source code
2870      * @since 1.5
2871      */
2872     public boolean isEnum() {
2873         // An enum must both directly extend java.lang.Enum and have
2874         // the ENUM bit set; classes for specialized enum constants
2875         // don't do the former.
2876         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
2877         this.getSuperclass() == java.lang.Enum.class;
2878     }
2879 
2880     // Fetches the factory for reflective objects
2881     private static ReflectionFactory getReflectionFactory() {
2882         if (reflectionFactory == null) {
2883             reflectionFactory =
2884                 java.security.AccessController.doPrivileged
2885                     (new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
2886         }
2887         return reflectionFactory;
2888     }
2889     private static ReflectionFactory reflectionFactory;
2890 
2891     // To be able to query system properties as soon as they're available
2892     private static boolean initted = false;
2893     private static void checkInitted() {
2894         if (initted) return;
2895         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
2896                 public Void run() {
2897                     // Tests to ensure the system properties table is fully
2898                     // initialized. This is needed because reflection code is
2899                     // called very early in the initialization process (before
2900                     // command-line arguments have been parsed and therefore
2901                     // these user-settable properties installed.) We assume that
2902                     // if System.out is non-null then the System class has been
2903                     // fully initialized and that the bulk of the startup code
2904                     // has been run.
2905 
2906                     if (System.out == null) {
2907                         // java.lang.System not yet fully initialized
2908                         return null;
2909                     }
2910 
2911                     // Doesn't use Boolean.getBoolean to avoid class init.
2912                     String val =
2913                         System.getProperty("sun.reflect.noCaches");
2914                     if (val != null &amp;&amp; val.equals("true")) {
2915                         useCaches = false;
2916                     }
2917 
2918                     initted = true;
2919                     return null;
2920                 }
2921             });
2922     }
2923 
2924     /**
2925      * Returns the elements of this enum class or null if this
2926      * Class object does not represent an enum type.
2927      *
2928      * @return an array containing the values comprising the enum class
2929      *     represented by this Class object in the order they're
2930      *     declared, or null if this Class object does not
2931      *     represent an enum type
2932      * @since 1.5
2933      */
2934     public T[] getEnumConstants() {
2935         T[] values = getEnumConstantsShared();
2936         return (values != null) ? values.clone() : null;
2937     }
2938 
2939     /**
2940      * Returns the elements of this enum class or null if this
2941      * Class object does not represent an enum type;
2942      * identical to getEnumConstants except that the result is
2943      * uncloned, cached, and shared by all callers.
2944      */
2945     T[] getEnumConstantsShared() {
2946         if (enumConstants == null) {
2947             if (!isEnum()) return null;
2948             try {
2949                 final Method values = getMethod("values");
2950                 java.security.AccessController.doPrivileged(
2951                     new java.security.PrivilegedAction&lt;Void&gt;() {
2952                         public Void run() {
2953                                 values.setAccessible(true);
2954                                 return null;
2955                             }
2956                         });
2957                 @SuppressWarnings("unchecked")
2958                 T[] temporaryConstants = (T[])values.invoke(null);
2959                 enumConstants = temporaryConstants;
2960             }
2961             // These can happen when users concoct enum-like classes
2962             // that don't comply with the enum spec.
2963             catch (InvocationTargetException | NoSuchMethodException |
2964                    IllegalAccessException ex) { return null; }
2965         }
2966         return enumConstants;
2967     }
2968     private volatile transient T[] enumConstants = null;
2969 
2970     /**
2971      * Returns a map from simple name to enum constant.  This package-private
2972      * method is used internally by Enum to implement
2973      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
2974      * efficiently.  Note that the map is returned by this method is
2975      * created lazily on first use.  Typically it won't ever get created.
2976      */
2977     Map&lt;String, T&gt; enumConstantDirectory() {
2978         if (enumConstantDirectory == null) {
2979             T[] universe = getEnumConstantsShared();
2980             if (universe == null)
2981                 throw new IllegalArgumentException(
2982                     getName() + " is not an enum type");
2983             Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length);
2984             for (T constant : universe)
2985                 m.put(((Enum&lt;?&gt;)constant).name(), constant);
2986             enumConstantDirectory = m;
2987         }
2988         return enumConstantDirectory;
2989     }
2990     private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null;
2991 
2992     /**
2993      * Casts an object to the class or interface represented
2994      * by this {@code Class} object.
2995      *
2996      * @param obj the object to be cast
2997      * @return the object after casting, or null if obj is null
2998      *
2999      * @throws ClassCastException if the object is not
3000      * null and is not assignable to the type T.
3001      *
3002      * @since 1.5
3003      */
3004     @SuppressWarnings("unchecked")
3005     public T cast(Object obj) {
3006         if (obj != null &amp;&amp; !isInstance(obj))
3007             throw new ClassCastException(cannotCastMsg(obj));
3008         return (T) obj;
3009     }
3010 
3011     private String cannotCastMsg(Object obj) {
3012         return "Cannot cast " + obj.getClass().getName() + " to " + getName();
3013     }
3014 
3015     /**
3016      * Casts this {@code Class} object to represent a subclass of the class
3017      * represented by the specified class object.  Checks that the cast
3018      * is valid, and throws a {@code ClassCastException} if it is not.  If
3019      * this method succeeds, it always returns a reference to this class object.
3020      *
3021      * &lt;p&gt;This method is useful when a client needs to "narrow" the type of
3022      * a {@code Class} object to pass it to an API that restricts the
3023      * {@code Class} objects that it is willing to accept.  A cast would
3024      * generate a compile-time warning, as the correctness of the cast
3025      * could not be checked at runtime (because generic types are implemented
3026      * by erasure).
3027      *
3028      * @return this {@code Class} object, cast to represent a subclass of
3029      *    the specified class object.
3030      * @throws ClassCastException if this {@code Class} object does not
3031      *    represent a subclass of the specified class (here "subclass" includes
3032      *    the class itself).
3033      * @since 1.5
3034      */
3035     @SuppressWarnings("unchecked")
3036     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3037         if (clazz.isAssignableFrom(this))
3038             return (Class&lt;? extends U&gt;) this;
3039         else
3040             throw new ClassCastException(this.toString());
3041     }
3042 
3043     /**
3044      * @throws NullPointerException {@inheritDoc}
3045      * @since 1.5
3046      */
3047     @SuppressWarnings("unchecked")
3048     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3049         if (annotationClass == null)
3050             throw new NullPointerException();
3051 
<a name="21" id="anc21"></a><span class="changed">3052         initAnnotationsIfNecessary();</span>
<span class="changed">3053         return (A) annotations.get(annotationClass);</span>
3054     }
3055 
3056     /**
3057      * @throws NullPointerException {@inheritDoc}
3058      * @since 1.5
3059      */
3060     public boolean isAnnotationPresent(
3061         Class&lt;? extends Annotation&gt; annotationClass) {
3062         if (annotationClass == null)
3063             throw new NullPointerException();
3064 
3065         return getAnnotation(annotationClass) != null;
3066     }
3067 
3068 
3069     /**
3070      * @since 1.5
3071      */
3072     public Annotation[] getAnnotations() {
<a name="22" id="anc22"></a><span class="changed">3073         initAnnotationsIfNecessary();</span>
<span class="changed">3074         return AnnotationParser.toArray(annotations);</span>
3075     }
3076 
3077     /**
3078      * @since 1.5
3079      */
3080     public Annotation[] getDeclaredAnnotations()  {
<a name="23" id="anc23"></a><span class="changed">3081         initAnnotationsIfNecessary();</span>
<span class="changed">3082         return AnnotationParser.toArray(declaredAnnotations);</span>
3083     }
3084 
<a name="24" id="anc24"></a><span class="removed">3085     // Annotations cache</span>
<span class="removed">3086     private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
<span class="removed">3087     private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span>
3088 
<a name="25" id="anc25"></a><span class="changed">3089     private synchronized void initAnnotationsIfNecessary() {</span>
<span class="changed">3090         clearCachesOnClassRedefinition();</span>
<span class="changed">3091         if (annotations != null)</span>
<span class="changed">3092             return;</span>
<span class="changed">3093         declaredAnnotations = AnnotationParser.parseAnnotations(</span>




3094             getRawAnnotations(), getConstantPool(), this);
<a name="26" id="anc26"></a>
3095         Class&lt;?&gt; superClass = getSuperclass();
3096         if (superClass == null) {
3097             annotations = declaredAnnotations;
3098         } else {
3099             annotations = new HashMap&lt;&gt;();
<a name="27" id="anc27"></a><span class="changed">3100             superClass.initAnnotationsIfNecessary();</span>
<span class="changed">3101             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superClass.annotations.entrySet()) {</span>
3102                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
3103                 if (AnnotationType.getInstance(annotationClass).isInherited())
3104                     annotations.put(annotationClass, e.getValue());
3105             }
3106             annotations.putAll(declaredAnnotations);
3107         }
<a name="28" id="anc28"></a>






3108     }
3109 
3110     // Annotation types cache their internal (AnnotationType) form
3111 
3112     private AnnotationType annotationType;
3113 
3114     void setAnnotationType(AnnotationType type) {
3115         annotationType = type;
3116     }
3117 
3118     AnnotationType getAnnotationType() {
3119         return annotationType;
3120     }
3121 
3122     /* Backing store of user-defined values pertaining to this class.
3123      * Maintained by the ClassValue class.
3124      */
3125     transient ClassValue.ClassValueMap classValueMap;
3126 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="29" type="hidden" /></form></body></html>
