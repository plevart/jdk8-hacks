<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Udiff src/share/classes/java/lang/Class.java</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<h2>src/share/classes/java/lang/Class.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev 6075 : Class.getAnnotaion() synchronization bottleneck and JEP-149 proposal</pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -1,7 +1,7 @@</span>
 /*
<span class="removed">- * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.</span>
<span class="new">+ * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.</span>
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
</pre><hr /><pre>
<span class="newmarker">@@ -2210,43 +2210,76 @@</span>
      * Reflection support.
      */
 
     // Caches for certain reflective results
     private static boolean useCaches = true;
<span class="removed">-    private volatile transient SoftReference&lt;Field[]&gt; declaredFields;</span>
<span class="removed">-    private volatile transient SoftReference&lt;Field[]&gt; publicFields;</span>
<span class="removed">-    private volatile transient SoftReference&lt;Method[]&gt; declaredMethods;</span>
<span class="removed">-    private volatile transient SoftReference&lt;Method[]&gt; publicMethods;</span>
<span class="removed">-    private volatile transient SoftReference&lt;Constructor&lt;T&gt;[]&gt; declaredConstructors;</span>
<span class="removed">-    private volatile transient SoftReference&lt;Constructor&lt;T&gt;[]&gt; publicConstructors;</span>
<span class="new">+</span>
<span class="new">+    // volatile data that might get invalid when JVM TI RedefineClasses() is called</span>
<span class="new">+    static class VolatileData&lt;T&gt; {</span>
<span class="new">+        volatile Field[] declaredFields;</span>
<span class="new">+        volatile Field[] publicFields;</span>
<span class="new">+        volatile Method[] declaredMethods;</span>
<span class="new">+        volatile Method[] publicMethods;</span>
<span class="new">+        volatile Constructor&lt;T&gt;[] declaredConstructors;</span>
<span class="new">+        volatile Constructor&lt;T&gt;[] publicConstructors;</span>
     // Intermediate results for getFields and getMethods
<span class="removed">-    private volatile transient SoftReference&lt;Field[]&gt; declaredPublicFields;</span>
<span class="removed">-    private volatile transient SoftReference&lt;Method[]&gt; declaredPublicMethods;</span>
<span class="new">+        volatile Field[] declaredPublicFields;</span>
<span class="new">+        volatile Method[] declaredPublicMethods;</span>
<span class="new">+        // Annotations</span>
<span class="new">+        volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
<span class="new">+        volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span>
<span class="new">+        // Value of classRedefinedCount when we created this VolatileData instance</span>
<span class="new">+        final int redefinedCount;</span>
<span class="new">+</span>
<span class="new">+        VolatileData(int redefinedCount) {</span>
<span class="new">+            this.redefinedCount = redefinedCount;</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        // initialize Unsafe machinery here, since we need to call Class.class instance method and would like to avoid</span>
<span class="new">+        // calling it in the static initializer of the Class class...</span>
<span class="new">+        private static final Unsafe unsafe;</span>
<span class="new">+        // offset of Class.volatileData instance field</span>
<span class="new">+        private static final long volatileDataOffset;</span>
<span class="new">+</span>
<span class="new">+        static {</span>
<span class="new">+            unsafe = Unsafe.getUnsafe();</span>
<span class="new">+            // bypass caches</span>
<span class="new">+            Field volatileDataField = searchFields(Class.class.getDeclaredFields0(false), "volatileData");</span>
<span class="new">+            if (volatileDataField == null) throw new Error("No volatileData field found in java.lang.Class");</span>
<span class="new">+            volatileDataOffset = unsafe.objectFieldOffset(volatileDataField);</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        static &lt;T&gt; boolean compareAndSwap(Class&lt;?&gt; clazz, SoftReference&lt;VolatileData&lt;T&gt;&gt; oldData, SoftReference&lt;VolatileData&lt;T&gt;&gt; newData) {</span>
<span class="new">+            return unsafe.compareAndSwapObject(clazz, volatileDataOffset, oldData, newData);</span>
<span class="new">+        }</span>
<span class="new">+    }</span>
<span class="new">+    </span>
<span class="new">+    private volatile transient SoftReference&lt;VolatileData&lt;T&gt;&gt; volatileData;</span>
 
     // Incremented by the VM on each call to JVM TI RedefineClasses()
     // that redefines this class or a superclass.
     private volatile transient int classRedefinedCount = 0;
 
<span class="removed">-    // Value of classRedefinedCount when we last cleared the cached values</span>
<span class="removed">-    // that are sensitive to class redefinition.</span>
<span class="removed">-    private volatile transient int lastRedefinedCount = 0;</span>
<span class="removed">-</span>
<span class="removed">-    // Clears cached values that might possibly have been obsoleted by</span>
<span class="removed">-    // a class redefinition.</span>
<span class="removed">-    private void clearCachesOnClassRedefinition() {</span>
<span class="removed">-        if (lastRedefinedCount != classRedefinedCount) {</span>
<span class="removed">-            declaredFields = publicFields = declaredPublicFields = null;</span>
<span class="removed">-            declaredMethods = publicMethods = declaredPublicMethods = null;</span>
<span class="removed">-            declaredConstructors = publicConstructors = null;</span>
<span class="removed">-            annotations = declaredAnnotations = null;</span>
<span class="removed">-</span>
<span class="removed">-            // Use of "volatile" (and synchronization by caller in the case</span>
<span class="removed">-            // of annotations) ensures that no thread sees the update to</span>
<span class="removed">-            // lastRedefinedCount before seeing the caches cleared.</span>
<span class="removed">-            // We do not guard against brief windows during which multiple</span>
<span class="removed">-            // threads might redundantly work to fill an empty cache.</span>
<span class="removed">-            lastRedefinedCount = classRedefinedCount;</span>
<span class="new">+    // Lazily create and cache VolatileData</span>
<span class="new">+    private VolatileData&lt;T&gt; volatileData() {</span>
<span class="new">+        if (!useCaches) return null;</span>
<span class="new">+</span>
<span class="new">+        while (true)</span>
<span class="new">+        {</span>
<span class="new">+            SoftReference&lt;VolatileData&lt;T&gt;&gt; volatileData = this.volatileData;</span>
<span class="new">+            int classRedefinedCount = this.classRedefinedCount;</span>
<span class="new">+            VolatileData&lt;T&gt; vd;</span>
<span class="new">+            if (volatileData != null &amp;&amp; (vd = volatileData.get()) != null &amp;&amp; vd.redefinedCount == classRedefinedCount) {</span>
<span class="new">+                return vd;</span>
<span class="new">+            }</span>
<span class="new">+            // no SoftReference or cleared SoftReference or stale VolatileData</span>
<span class="new">+            vd = new VolatileData&lt;T&gt;(classRedefinedCount);</span>
<span class="new">+            // try to CAS it...</span>
<span class="new">+            if (VolatileData.compareAndSwap(this, volatileData, new SoftReference&lt;VolatileData&lt;T&gt;&gt;(vd))) {</span>
<span class="new">+                return vd;</span>
<span class="new">+            }</span>
<span class="new">+            // else retry</span>
         }
     }
 
     // Generic signature handling
     private native String getGenericSignature();
</pre><hr /><pre>
<span class="newmarker">@@ -2286,30 +2319,22 @@</span>
     // be propagated to the outside world, but must instead be copied
     // via ReflectionFactory.copyField.
     private Field[] privateGetDeclaredFields(boolean publicOnly) {
         checkInitted();
         Field[] res = null;
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            clearCachesOnClassRedefinition();</span>
<span class="removed">-            if (publicOnly) {</span>
<span class="removed">-                if (declaredPublicFields != null) {</span>
<span class="removed">-                    res = declaredPublicFields.get();</span>
<span class="removed">-                }</span>
<span class="removed">-            } else {</span>
<span class="removed">-                if (declaredFields != null) {</span>
<span class="removed">-                    res = declaredFields.get();</span>
<span class="removed">-                }</span>
<span class="removed">-            }</span>
<span class="new">+        VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            res = publicOnly ? vd.declaredPublicFields : vd.declaredFields;</span>
             if (res != null) return res;
         }
         // No cached value available; request value from VM
         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
<span class="removed">-        if (useCaches) {</span>
<span class="new">+        if (vd != null) {</span>
             if (publicOnly) {
<span class="removed">-                declaredPublicFields = new SoftReference&lt;&gt;(res);</span>
<span class="new">+                vd.declaredPublicFields = res;</span>
             } else {
<span class="removed">-                declaredFields = new SoftReference&lt;&gt;(res);</span>
<span class="new">+                vd.declaredFields = res;</span>
             }
         }
         return res;
     }
 
</pre><hr /><pre>
<span class="newmarker">@@ -2317,15 +2342,13 @@</span>
     // be propagated to the outside world, but must instead be copied
     // via ReflectionFactory.copyField.
     private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {
         checkInitted();
         Field[] res = null;
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            clearCachesOnClassRedefinition();</span>
<span class="removed">-            if (publicFields != null) {</span>
<span class="removed">-                res = publicFields.get();</span>
<span class="removed">-            }</span>
<span class="new">+        VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            res = vd.publicFields;</span>
             if (res != null) return res;
         }
 
         // No cached value available; compute value recursively.
         // Traverse in correct order for getField().
</pre><hr /><pre>
<span class="newmarker">@@ -2354,12 +2377,12 @@</span>
             }
         }
 
         res = new Field[fields.size()];
         fields.toArray(res);
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            publicFields = new SoftReference&lt;&gt;(res);</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            vd.publicFields = res;</span>
         }
         return res;
     }
 
     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
</pre><hr /><pre>
<span class="newmarker">@@ -2379,36 +2402,28 @@</span>
     // objects must NOT be propagated to the outside world, but must
     // instead be copied via ReflectionFactory.copyConstructor.
     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
         checkInitted();
         Constructor&lt;T&gt;[] res = null;
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            clearCachesOnClassRedefinition();</span>
<span class="removed">-            if (publicOnly) {</span>
<span class="removed">-                if (publicConstructors != null) {</span>
<span class="removed">-                    res = publicConstructors.get();</span>
<span class="removed">-                }</span>
<span class="removed">-            } else {</span>
<span class="removed">-                if (declaredConstructors != null) {</span>
<span class="removed">-                    res = declaredConstructors.get();</span>
<span class="removed">-                }</span>
<span class="removed">-            }</span>
<span class="new">+        VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            res = publicOnly ? vd.publicConstructors : vd.declaredConstructors;</span>
             if (res != null) return res;
         }
         // No cached value available; request value from VM
         if (isInterface()) {
             @SuppressWarnings("unchecked")
             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
             res = temporaryRes;
         } else {
             res = getDeclaredConstructors0(publicOnly);
         }
<span class="removed">-        if (useCaches) {</span>
<span class="new">+        if (vd != null) {</span>
             if (publicOnly) {
<span class="removed">-                publicConstructors = new SoftReference&lt;&gt;(res);</span>
<span class="new">+                vd.publicConstructors = res;</span>
             } else {
<span class="removed">-                declaredConstructors = new SoftReference&lt;&gt;(res);</span>
<span class="new">+                vd.declaredConstructors = res;</span>
             }
         }
         return res;
     }
 
</pre><hr /><pre>
<span class="newmarker">@@ -2422,30 +2437,22 @@</span>
     // be propagated to the outside world, but must instead be copied
     // via ReflectionFactory.copyMethod.
     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
         checkInitted();
         Method[] res = null;
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            clearCachesOnClassRedefinition();</span>
<span class="removed">-            if (publicOnly) {</span>
<span class="removed">-                if (declaredPublicMethods != null) {</span>
<span class="removed">-                    res = declaredPublicMethods.get();</span>
<span class="removed">-                }</span>
<span class="removed">-            } else {</span>
<span class="removed">-                if (declaredMethods != null) {</span>
<span class="removed">-                    res = declaredMethods.get();</span>
<span class="removed">-                }</span>
<span class="removed">-            }</span>
<span class="new">+        VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            res = publicOnly ? vd.declaredPublicMethods : vd.declaredMethods;</span>
             if (res != null) return res;
         }
         // No cached value available; request value from VM
         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
         if (useCaches) {
             if (publicOnly) {
<span class="removed">-                declaredPublicMethods = new SoftReference&lt;&gt;(res);</span>
<span class="new">+                vd.declaredPublicMethods = res;</span>
             } else {
<span class="removed">-                declaredMethods = new SoftReference&lt;&gt;(res);</span>
<span class="new">+                vd.declaredMethods = res;</span>
             }
         }
         return res;
     }
 
</pre><hr /><pre>
<span class="newmarker">@@ -2544,15 +2551,13 @@</span>
     // be propagated to the outside world, but must instead be copied
     // via ReflectionFactory.copyMethod.
     private Method[] privateGetPublicMethods() {
         checkInitted();
         Method[] res = null;
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            clearCachesOnClassRedefinition();</span>
<span class="removed">-            if (publicMethods != null) {</span>
<span class="removed">-                res = publicMethods.get();</span>
<span class="removed">-            }</span>
<span class="new">+        VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            res = vd.publicMethods;</span>
             if (res != null) return res;
         }
 
         // No cached value available; compute value recursively.
         // Start by fetching public declared methods
</pre><hr /><pre>
<span class="newmarker">@@ -2596,22 +2601,22 @@</span>
             inheritedMethods.removeByNameAndSignature(m);
         }
         methods.addAllIfNotPresent(inheritedMethods);
         methods.compactAndTrim();
         res = methods.getArray();
<span class="removed">-        if (useCaches) {</span>
<span class="removed">-            publicMethods = new SoftReference&lt;&gt;(res);</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            vd.publicMethods = res;</span>
         }
         return res;
     }
 
 
     //
     // Helpers for fetchers of one field, method, or constructor
     //
 
<span class="removed">-    private Field searchFields(Field[] fields, String name) {</span>
<span class="new">+    private static Field searchFields(Field[] fields, String name) {</span>
         String internedName = name.intern();
         for (int i = 0; i &lt; fields.length; i++) {
             if (fields[i].getName() == internedName) {
                 return getReflectionFactory().copyField(fields[i]);
             }
</pre><hr /><pre>
<span class="newmarker">@@ -3047,12 +3052,11 @@</span>
     @SuppressWarnings("unchecked")
     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
         if (annotationClass == null)
             throw new NullPointerException();
 
<span class="removed">-        initAnnotationsIfNecessary();</span>
<span class="removed">-        return (A) annotations.get(annotationClass);</span>
<span class="new">+        return (A) privateGetAnnotations(false).get(annotationClass);</span>
     }
 
     /**
      * @throws NullPointerException {@inheritDoc}
      * @since 1.5
</pre><hr /><pre>
<span class="newmarker">@@ -3068,45 +3072,51 @@</span>
 
     /**
      * @since 1.5
      */
     public Annotation[] getAnnotations() {
<span class="removed">-        initAnnotationsIfNecessary();</span>
<span class="removed">-        return AnnotationParser.toArray(annotations);</span>
<span class="new">+        return AnnotationParser.toArray(privateGetAnnotations(false));</span>
     }
 
     /**
      * @since 1.5
      */
     public Annotation[] getDeclaredAnnotations()  {
<span class="removed">-        initAnnotationsIfNecessary();</span>
<span class="removed">-        return AnnotationParser.toArray(declaredAnnotations);</span>
<span class="new">+        return AnnotationParser.toArray(privateGetAnnotations(true));</span>
     }
 
<span class="removed">-    // Annotations cache</span>
<span class="removed">-    private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
<span class="removed">-    private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span>
 
<span class="removed">-    private synchronized void initAnnotationsIfNecessary() {</span>
<span class="removed">-        clearCachesOnClassRedefinition();</span>
<span class="removed">-        if (annotations != null)</span>
<span class="removed">-            return;</span>
<span class="removed">-        declaredAnnotations = AnnotationParser.parseAnnotations(</span>
<span class="new">+    private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; privateGetAnnotations(boolean declaredOnly) {</span>
<span class="new">+        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; res;</span>
<span class="new">+        VolatileData&lt;T&gt; vd = volatileData();</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            res = declaredOnly ? vd.declaredAnnotations : vd.annotations;</span>
<span class="new">+            if (res != null) return res;</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations = AnnotationParser.parseAnnotations(</span>
             getRawAnnotations(), getConstantPool(), this);
<span class="new">+        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span>
         Class&lt;?&gt; superClass = getSuperclass();
         if (superClass == null) {
             annotations = declaredAnnotations;
         } else {
             annotations = new HashMap&lt;&gt;();
<span class="removed">-            superClass.initAnnotationsIfNecessary();</span>
<span class="removed">-            for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superClass.annotations.entrySet()) {</span>
<span class="new">+            for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superClass.privateGetAnnotations(false).entrySet()) {</span>
                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
                 if (AnnotationType.getInstance(annotationClass).isInherited())
                     annotations.put(annotationClass, e.getValue());
             }
             annotations.putAll(declaredAnnotations);
         }
<span class="new">+</span>
<span class="new">+        if (vd != null) {</span>
<span class="new">+            vd.annotations = annotations;</span>
<span class="new">+            vd.declaredAnnotations = declaredAnnotations;</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        return declaredOnly ? declaredAnnotations : annotations;</span>
     }
 
     // Annotation types cache their internal (AnnotationType) form
 
     private AnnotationType annotationType;
</pre></body></html>

