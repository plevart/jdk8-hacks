<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/classes/java/lang/reflect/Method.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import sun.reflect.MethodAccessor;
  29 import sun.reflect.Reflection;
  30 import sun.reflect.generics.repository.MethodRepository;
  31 import sun.reflect.generics.factory.CoreReflectionFactory;
  32 import sun.reflect.generics.factory.GenericsFactory;
  33 import sun.reflect.generics.scope.MethodScope;
  34 import sun.reflect.annotation.AnnotationType;
  35 import sun.reflect.annotation.AnnotationParser;
  36 import java.lang.annotation.Annotation;
  37 import java.lang.annotation.AnnotationFormatError;
  38 import java.nio.ByteBuffer;
  39 
  40 /**
  41  * A {@code Method} provides information about, and access to, a single method
  42  * on a class or interface.  The reflected method may be a class method
  43  * or an instance method (including an abstract method).
  44  *
  45  * &lt;p&gt;A {@code Method} permits widening conversions to occur when matching the
  46  * actual parameters to invoke with the underlying method's formal
  47  * parameters, but it throws an {@code IllegalArgumentException} if a
  48  * narrowing conversion would occur.
  49  *
  50  * @see Member
  51  * @see java.lang.Class
  52  * @see java.lang.Class#getMethods()
  53  * @see java.lang.Class#getMethod(String, Class[])
  54  * @see java.lang.Class#getDeclaredMethods()
  55  * @see java.lang.Class#getDeclaredMethod(String, Class[])
  56  *
  57  * @author Kenneth Russell
  58  * @author Nakul Saraiya
  59  */
  60 public final class Method extends Executable {
  61     private Class&lt;?&gt;            clazz;
  62     private int                 slot;
  63     // This is guaranteed to be interned by the VM in the 1.4
  64     // reflection implementation
  65     private String              name;
  66     private Class&lt;?&gt;            returnType;
  67     private Class&lt;?&gt;[]          parameterTypes;
  68     private Class&lt;?&gt;[]          exceptionTypes;
  69     private int                 modifiers;
  70     // Generics and annotations support
  71     private transient String              signature;
  72     // generic info repository; lazily initialized
  73     private transient MethodRepository genericInfo;
  74     private byte[]              annotations;
  75     private byte[]              parameterAnnotations;
  76     private byte[]              annotationDefault;
  77     private volatile MethodAccessor methodAccessor;
  78     // For sharing of MethodAccessors. This branching structure is
  79     // currently only two levels deep (i.e., one root Method and
  80     // potentially many Method objects pointing to it.)
  81     private Method              root;
  82 
  83 
  84     // Generics infrastructure
  85     private String getGenericSignature() {return signature;}
  86 
  87     // Accessor for factory
  88     private GenericsFactory getFactory() {
  89         // create scope and factory
  90         return CoreReflectionFactory.make(this, MethodScope.make(this));
  91     }
  92 
  93     // Accessor for generic info repository
  94     @Override
  95     MethodRepository getGenericInfo() {
  96         // lazily initialize repository if necessary
  97         if (genericInfo == null) {
  98             // create and cache generic info repository
  99             genericInfo = MethodRepository.make(getGenericSignature(),
 100                                                 getFactory());
 101         }
 102         return genericInfo; //return cached repository
 103     }
 104 
 105     /**
 106      * Package-private constructor used by ReflectAccess to enable
 107      * instantiation of these objects in Java code from the java.lang
 108      * package via sun.reflect.LangReflectAccess.
 109      */
 110     Method(Class&lt;?&gt; declaringClass,
 111            String name,
 112            Class&lt;?&gt;[] parameterTypes,
 113            Class&lt;?&gt; returnType,
 114            Class&lt;?&gt;[] checkedExceptions,
 115            int modifiers,
 116            int slot,
 117            String signature,
 118            byte[] annotations,
 119            byte[] parameterAnnotations,
 120            byte[] annotationDefault) {
 121         this.clazz = declaringClass;
 122         this.name = name;
 123         this.parameterTypes = parameterTypes;
 124         this.returnType = returnType;
 125         this.exceptionTypes = checkedExceptions;
 126         this.modifiers = modifiers;
 127         this.slot = slot;
 128         this.signature = signature;
 129         this.annotations = annotations;
 130         this.parameterAnnotations = parameterAnnotations;
 131         this.annotationDefault = annotationDefault;
 132     }
 133 
 134     /**
 135      * Package-private routine (exposed to java.lang.Class via
 136      * ReflectAccess) which returns a copy of this Method. The copy's
 137      * "root" field points to this Method.
 138      */
 139     Method copy() {
 140         // This routine enables sharing of MethodAccessor objects
 141         // among Method objects which refer to the same underlying
 142         // method in the VM. (All of this contortion is only necessary
 143         // because of the "accessibility" bit in AccessibleObject,
 144         // which implicitly requires that new java.lang.reflect
 145         // objects be fabricated for each reflective call on Class
 146         // objects.)
 147         Method res = new Method(clazz, name, parameterTypes, returnType,
 148                                 exceptionTypes, modifiers, slot, signature,
 149                                 annotations, parameterAnnotations, annotationDefault);
 150         res.root = this;
 151         // Might as well eagerly propagate this if already present
 152         res.methodAccessor = methodAccessor;
 153         return res;
 154     }
 155 
 156     @Override
 157     boolean hasGenericInformation() {
 158         return (getGenericSignature() != null);
 159     }
 160 
 161     @Override
 162     byte[] getAnnotationBytes() {
 163         return annotations;
 164     }
 165 
 166     /**
 167      * {@inheritDoc}
 168      */
 169     @Override
 170     public Class&lt;?&gt; getDeclaringClass() {
 171         return clazz;
 172     }
 173 
 174     /**
 175      * Returns the name of the method represented by this {@code Method}
 176      * object, as a {@code String}.
 177      */
 178     @Override
 179     public String getName() {
 180         return name;
 181     }
 182 
 183     /**
 184      * {@inheritDoc}
 185      */
 186     @Override
 187     public int getModifiers() {
 188         return modifiers;
 189     }
 190 
 191     /**
 192      * {@inheritDoc}
 193      * @throws GenericSignatureFormatError {@inheritDoc}
 194      * @since 1.5
 195      */
 196     @Override
 197     @SuppressWarnings({"rawtypes", "unchecked"})
 198     public TypeVariable&lt;Method&gt;[] getTypeParameters() {
 199         if (getGenericSignature() != null)
 200             return (TypeVariable&lt;Method&gt;[])getGenericInfo().getTypeParameters();
 201         else
 202             return (TypeVariable&lt;Method&gt;[])new TypeVariable[0];
 203     }
 204 
 205     /**
 206      * Returns a {@code Class} object that represents the formal return type
 207      * of the method represented by this {@code Method} object.
 208      *
 209      * @return the return type for the method this object represents
 210      */
 211     public Class&lt;?&gt; getReturnType() {
 212         return returnType;
 213     }
 214 
 215     /**
 216      * Returns a {@code Type} object that represents the formal return
 217      * type of the method represented by this {@code Method} object.
 218      *
 219      * &lt;p&gt;If the return type is a parameterized type,
 220      * the {@code Type} object returned must accurately reflect
 221      * the actual type parameters used in the source code.
 222      *
 223      * &lt;p&gt;If the return type is a type variable or a parameterized type, it
 224      * is created. Otherwise, it is resolved.
 225      *
 226      * @return  a {@code Type} object that represents the formal return
 227      *     type of the underlying  method
 228      * @throws GenericSignatureFormatError
 229      *     if the generic method signature does not conform to the format
 230      *     specified in
 231      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 232      * @throws TypeNotPresentException if the underlying method's
 233      *     return type refers to a non-existent type declaration
 234      * @throws MalformedParameterizedTypeException if the
 235      *     underlying method's return typed refers to a parameterized
 236      *     type that cannot be instantiated for any reason
 237      * @since 1.5
 238      */
 239     public Type getGenericReturnType() {
 240       if (getGenericSignature() != null) {
 241         return getGenericInfo().getReturnType();
 242       } else { return getReturnType();}
 243     }
 244 
 245     /**
 246      * {@inheritDoc}
 247      */
 248     @Override
 249     public Class&lt;?&gt;[] getParameterTypes() {
 250         return parameterTypes.clone();
 251     }
 252 
 253     /**
 254      * {@inheritDoc}
 255      * @throws GenericSignatureFormatError {@inheritDoc}
 256      * @throws TypeNotPresentException {@inheritDoc}
 257      * @throws MalformedParameterizedTypeException {@inheritDoc}
 258      * @since 1.5
 259      */
 260     @Override
 261     public Type[] getGenericParameterTypes() {
 262         return super.getGenericParameterTypes();
 263     }
 264 
 265     /**
 266      * {@inheritDoc}
 267      */
 268     @Override
 269     public Class&lt;?&gt;[] getExceptionTypes() {
 270         return exceptionTypes.clone();
 271     }
 272 
 273     /**
 274      * {@inheritDoc}
 275      * @throws GenericSignatureFormatError {@inheritDoc}
 276      * @throws TypeNotPresentException {@inheritDoc}
 277      * @throws MalformedParameterizedTypeException {@inheritDoc}
 278      * @since 1.5
 279      */
 280     @Override
 281     public Type[] getGenericExceptionTypes() {
 282         return super.getGenericExceptionTypes();
 283     }
 284 
 285     /**
 286      * Compares this {@code Method} against the specified object.  Returns
 287      * true if the objects are the same.  Two {@code Methods} are the same if
 288      * they were declared by the same class and have the same name
 289      * and formal parameter types and return type.
 290      */
 291     public boolean equals(Object obj) {
 292         if (obj != null &amp;&amp; obj instanceof Method) {
 293             Method other = (Method)obj;
 294             if ((getDeclaringClass() == other.getDeclaringClass())
 295                 &amp;&amp; (getName() == other.getName())) {
 296                 if (!returnType.equals(other.getReturnType()))
 297                     return false;
 298                 return equalParamTypes(parameterTypes, other.parameterTypes);
 299             }
 300         }
 301         return false;
 302     }
 303 
 304     /**
 305      * Returns a hashcode for this {@code Method}.  The hashcode is computed
 306      * as the exclusive-or of the hashcodes for the underlying
 307      * method's declaring class name and the method's name.
 308      */
 309     public int hashCode() {
 310         return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
 311     }
 312 
 313     /**
 314      * Returns a string describing this {@code Method}.  The string is
 315      * formatted as the method access modifiers, if any, followed by
 316      * the method return type, followed by a space, followed by the
 317      * class declaring the method, followed by a period, followed by
 318      * the method name, followed by a parenthesized, comma-separated
 319      * list of the method's formal parameter types. If the method
 320      * throws checked exceptions, the parameter list is followed by a
 321      * space, followed by the word throws followed by a
 322      * comma-separated list of the thrown exception types.
 323      * For example:
 324      * &lt;pre&gt;
 325      *    public boolean java.lang.Object.equals(java.lang.Object)
 326      * &lt;/pre&gt;
 327      *
 328      * &lt;p&gt;The access modifiers are placed in canonical order as
 329      * specified by "The Java Language Specification".  This is
 330      * {@code public}, {@code protected} or {@code private} first,
 331      * and then other modifiers in the following order:
 332      * {@code abstract}, {@code static}, {@code final},
 333      * {@code synchronized}, {@code native}, {@code strictfp}.
 334      */
 335     public String toString() {
 336         return sharedToString(Modifier.methodModifiers(),
 337                               parameterTypes,
 338                               exceptionTypes);
 339     }
 340 
 341     @Override
 342     void specificToStringHeader(StringBuilder sb) {
 343         sb.append(Field.getTypeName(getReturnType())).append(' ');
 344         sb.append(Field.getTypeName(getDeclaringClass())).append('.');
 345         sb.append(getName());
 346     }
 347 
 348     /**
 349      * Returns a string describing this {@code Method}, including
 350      * type parameters.  The string is formatted as the method access
 351      * modifiers, if any, followed by an angle-bracketed
 352      * comma-separated list of the method's type parameters, if any,
 353      * followed by the method's generic return type, followed by a
 354      * space, followed by the class declaring the method, followed by
 355      * a period, followed by the method name, followed by a
 356      * parenthesized, comma-separated list of the method's generic
 357      * formal parameter types.
 358      *
 359      * If this method was declared to take a variable number of
 360      * arguments, instead of denoting the last parameter as
 361      * "&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/tt&gt;", it is denoted as
 362      * "&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/tt&gt;".
 363      *
 364      * A space is used to separate access modifiers from one another
 365      * and from the type parameters or return type.  If there are no
 366      * type parameters, the type parameter list is elided; if the type
 367      * parameter list is present, a space separates the list from the
 368      * class name.  If the method is declared to throw exceptions, the
 369      * parameter list is followed by a space, followed by the word
 370      * throws followed by a comma-separated list of the generic thrown
 371      * exception types.  If there are no type parameters, the type
 372      * parameter list is elided.
 373      *
 374      * &lt;p&gt;The access modifiers are placed in canonical order as
 375      * specified by "The Java Language Specification".  This is
 376      * {@code public}, {@code protected} or {@code private} first,
 377      * and then other modifiers in the following order:
 378      * {@code abstract}, {@code static}, {@code final},
 379      * {@code synchronized}, {@code native}, {@code strictfp}.
 380      *
 381      * @return a string describing this {@code Method},
 382      * include type parameters
 383      *
 384      * @since 1.5
 385      */
 386     @Override
 387     public String toGenericString() {
 388         return sharedToGenericString(Modifier.methodModifiers());
 389     }
 390 
 391     @Override
 392     void specificToGenericStringHeader(StringBuilder sb) {
 393         Type genRetType = getGenericReturnType();
 394         sb.append( ((genRetType instanceof Class&lt;?&gt;)?
 395                     Field.getTypeName((Class&lt;?&gt;)genRetType):genRetType.toString()))
 396             .append(' ');
 397 
 398         sb.append(Field.getTypeName(getDeclaringClass())).append('.');
 399         sb.append(getName());
 400     }
 401 
 402     /**
 403      * Invokes the underlying method represented by this {@code Method}
 404      * object, on the specified object with the specified parameters.
 405      * Individual parameters are automatically unwrapped to match
 406      * primitive formal parameters, and both primitive and reference
 407      * parameters are subject to method invocation conversions as
 408      * necessary.
 409      *
 410      * &lt;p&gt;If the underlying method is static, then the specified {@code obj}
 411      * argument is ignored. It may be null.
 412      *
 413      * &lt;p&gt;If the number of formal parameters required by the underlying method is
 414      * 0, the supplied {@code args} array may be of length 0 or null.
 415      *
 416      * &lt;p&gt;If the underlying method is an instance method, it is invoked
 417      * using dynamic method lookup as documented in The Java Language
 418      * Specification, Second Edition, section 15.12.4.4; in particular,
 419      * overriding based on the runtime type of the target object will occur.
 420      *
 421      * &lt;p&gt;If the underlying method is static, the class that declared
 422      * the method is initialized if it has not already been initialized.
 423      *
 424      * &lt;p&gt;If the method completes normally, the value it returns is
 425      * returned to the caller of invoke; if the value has a primitive
 426      * type, it is first appropriately wrapped in an object. However,
 427      * if the value has the type of an array of a primitive type, the
 428      * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in
 429      * other words, an array of primitive type is returned.  If the
 430      * underlying method return type is void, the invocation returns
 431      * null.
 432      *
 433      * @param obj  the object the underlying method is invoked from
 434      * @param args the arguments used for the method call
 435      * @return the result of dispatching the method represented by
 436      * this object on {@code obj} with parameters
 437      * {@code args}
 438      *
 439      * @exception IllegalAccessException    if this {@code Method} object
 440      *              is enforcing Java language access control and the underlying
 441      *              method is inaccessible.
 442      * @exception IllegalArgumentException  if the method is an
 443      *              instance method and the specified object argument
 444      *              is not an instance of the class or interface
 445      *              declaring the underlying method (or of a subclass
 446      *              or implementor thereof); if the number of actual
 447      *              and formal parameters differ; if an unwrapping
 448      *              conversion for primitive arguments fails; or if,
 449      *              after possible unwrapping, a parameter value
 450      *              cannot be converted to the corresponding formal
 451      *              parameter type by a method invocation conversion.
 452      * @exception InvocationTargetException if the underlying method
 453      *              throws an exception.
 454      * @exception NullPointerException      if the specified object is null
 455      *              and the method is an instance method.
 456      * @exception ExceptionInInitializerError if the initialization
 457      * provoked by this method fails.
 458      */
 459     public Object invoke(Object obj, Object... args)
 460         throws IllegalAccessException, IllegalArgumentException,
 461            InvocationTargetException
 462     {
 463         if (!override) {
 464             if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
 465                 Class&lt;?&gt; caller = Reflection.getCallerClass(1);
 466 
 467                 checkAccess(caller, clazz, obj, modifiers);
 468             }
 469         }
 470         MethodAccessor ma = methodAccessor;             // read volatile
 471         if (ma == null) {
 472             ma = acquireMethodAccessor();
 473         }
 474         return ma.invoke(obj, args);
 475     }
 476 
 477     /**
 478      * Returns {@code true} if this method is a bridge
 479      * method; returns {@code false} otherwise.
 480      *
 481      * @return true if and only if this method is a bridge
 482      * method as defined by the Java Language Specification.
 483      * @since 1.5
 484      */
 485     public boolean isBridge() {
 486         return (getModifiers() &amp; Modifier.BRIDGE) != 0;
 487     }
 488 
 489     /**
 490      * {@inheritDoc}
 491      * @since 1.5
 492      */
 493     @Override
 494     public boolean isVarArgs() {
 495         return super.isVarArgs();
 496     }
 497 
 498     /**
 499      * {@inheritDoc}
 500      * @since 1.5
 501      */
 502     @Override
 503     public boolean isSynthetic() {
 504         return super.isSynthetic();
 505     }
 506 
 507     // NOTE that there is no synchronization used here. It is correct
 508     // (though not efficient) to generate more than one MethodAccessor
 509     // for a given Method. However, avoiding synchronization will
 510     // probably make the implementation more scalable.
 511     private MethodAccessor acquireMethodAccessor() {
 512         // First check to see if one has been created yet, and take it
 513         // if so
 514         MethodAccessor tmp = null;
 515         if (root != null) tmp = root.getMethodAccessor();
 516         if (tmp != null) {
 517             methodAccessor = tmp;
 518         } else {
 519             // Otherwise fabricate one and propagate it up to the root
 520             tmp = reflectionFactory.newMethodAccessor(this);
 521             setMethodAccessor(tmp);
 522         }
 523 
 524         return tmp;
 525     }
 526 
 527     // Returns MethodAccessor for this Method object, not looking up
 528     // the chain to the root
 529     MethodAccessor getMethodAccessor() {
 530         return methodAccessor;
 531     }
 532 
 533     // Sets the MethodAccessor for this Method object and
 534     // (recursively) its root
 535     void setMethodAccessor(MethodAccessor accessor) {
 536         methodAccessor = accessor;
 537         // Propagate up
 538         if (root != null) {
 539             root.setMethodAccessor(accessor);
 540         }
 541     }
 542 
 543     /**
 544      * Returns the default value for the annotation member represented by
 545      * this {@code Method} instance.  If the member is of a primitive type,
 546      * an instance of the corresponding wrapper type is returned. Returns
 547      * null if no default is associated with the member, or if the method
 548      * instance does not represent a declared member of an annotation type.
 549      *
 550      * @return the default value for the annotation member represented
 551      *     by this {@code Method} instance.
 552      * @throws TypeNotPresentException if the annotation is of type
 553      *     {@link Class} and no definition can be found for the
 554      *     default class value.
 555      * @since  1.5
 556      */
 557     public Object getDefaultValue() {
 558         if  (annotationDefault == null)
 559             return null;
 560         Class&lt;?&gt; memberType = AnnotationType.invocationHandlerReturnType(
 561             getReturnType());
 562         Object result = AnnotationParser.parseMemberValue(
 563             memberType, ByteBuffer.wrap(annotationDefault),
 564             sun.misc.SharedSecrets.getJavaLangAccess().
 565                 getConstantPool(getDeclaringClass()),
 566             getDeclaringClass());
 567         if (result instanceof sun.reflect.annotation.ExceptionProxy)
 568             throw new AnnotationFormatError("Invalid default: " + this);
 569         return result;
 570     }
 571 
 572     /**
 573      * {@inheritDoc}
 574      * @throws NullPointerException  {@inheritDoc}
 575      * @since 1.5
 576      */
 577     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 578         return super.getAnnotation(annotationClass);
 579     }
 580 
 581     /**
 582      * {@inheritDoc}
 583      * @since 1.5
 584      */
 585     public Annotation[] getDeclaredAnnotations()  {
 586         return super.getDeclaredAnnotations();
 587     }
 588 
 589     /**
 590      * {@inheritDoc}
 591      * @since 1.5
 592      */
 593     @Override
 594     public Annotation[][] getParameterAnnotations() {
 595         return sharedGetParameterAnnotations(parameterTypes, parameterAnnotations);
 596     }
 597 
 598     @Override
 599     void handleParameterNumberMismatch(int resultLength, int numParameters) {
 600         throw new AnnotationFormatError("Parameter annotations don't match number of parameters");
 601     }
 602 }
</pre></body></html>
