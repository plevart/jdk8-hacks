<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev 6075 : Class.getAnnotaion() synchronization bottleneck and JEP-149 proposal</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import java.lang.annotation.*;
  29 import java.util.Map;
  30 import sun.reflect.annotation.AnnotationParser;
  31 import sun.reflect.generics.repository.ConstructorRepository;
  32 
  33 /**
  34  * A shared superclass for the common functionality of {@link Method}
  35  * and {@link Constructor}.
  36  *
  37  * @since 1.8
  38  */
  39 public abstract class Executable extends AccessibleObject
  40     implements Member, GenericDeclaration {
  41     /*
  42      * Only grant package-visibility to the constructor.
  43      */
  44     Executable() {}
  45 
  46     /**
  47      * Accessor method to allow code sharing
  48      */
  49     abstract byte[] getAnnotationBytes();
  50 
  51     /**
  52      * Does the Executable have generic information.
  53      */
  54     abstract boolean hasGenericInformation();
  55 
  56     abstract ConstructorRepository getGenericInfo();
  57 
  58     boolean equalParamTypes(Class&lt;?&gt;[] params1, Class&lt;?&gt;[] params2) {
  59         /* Avoid unnecessary cloning */
  60         if (params1.length == params2.length) {
  61             for (int i = 0; i &lt; params1.length; i++) {
  62                 if (params1[i] != params2[i])
  63                     return false;
  64             }
  65             return true;
  66         }
  67         return false;
  68     }
  69 
  70     Annotation[][] parseParameterAnnotations(byte[] parameterAnnotations) {
  71         return AnnotationParser.parseParameterAnnotations(
  72                parameterAnnotations,
  73                sun.misc.SharedSecrets.getJavaLangAccess().
  74                getConstantPool(getDeclaringClass()),
  75                getDeclaringClass());
  76     }
  77 
  78     void separateWithCommas(Class&lt;?&gt;[] types, StringBuilder sb) {
  79         for (int j = 0; j &lt; types.length; j++) {
  80             sb.append(Field.getTypeName(types[j]));
  81             if (j &lt; (types.length - 1))
  82                 sb.append(",");
  83         }
  84 
  85     }
  86 
  87     void printModifiersIfNonzero(StringBuilder sb, int mask) {
  88         int mod = getModifiers() &amp; mask;
  89         if (mod != 0) {
  90             sb.append(Modifier.toString(mod)).append(' ');
  91         }
  92     }
  93 
  94     String sharedToString(int modifierMask,
  95                           Class&lt;?&gt;[] parameterTypes,
  96                           Class&lt;?&gt;[] exceptionTypes) {
  97         try {
  98             StringBuilder sb = new StringBuilder();
  99 
 100             printModifiersIfNonzero(sb, modifierMask);
 101             specificToStringHeader(sb);
 102 
 103             sb.append('(');
 104             separateWithCommas(parameterTypes, sb);
 105             sb.append(')');
 106             if (exceptionTypes.length &gt; 0) {
 107                 sb.append(" throws ");
 108                 separateWithCommas(exceptionTypes, sb);
 109             }
 110             return sb.toString();
 111         } catch (Exception e) {
 112             return "&lt;" + e + "&gt;";
 113         }
 114     }
 115 
 116     /**
 117      * Generate toString header information specific to a method or
 118      * constructor.
 119      */
 120     abstract void specificToStringHeader(StringBuilder sb);
 121 
 122     String sharedToGenericString(int modifierMask) {
 123         try {
 124             StringBuilder sb = new StringBuilder();
 125 
 126             printModifiersIfNonzero(sb, modifierMask);
 127 
 128             TypeVariable&lt;?&gt;[] typeparms = getTypeParameters();
 129             if (typeparms.length &gt; 0) {
 130                 boolean first = true;
 131                 sb.append('&lt;');
 132                 for(TypeVariable&lt;?&gt; typeparm: typeparms) {
 133                     if (!first)
 134                         sb.append(',');
 135                     // Class objects can't occur here; no need to test
 136                     // and call Class.getName().
 137                     sb.append(typeparm.toString());
 138                     first = false;
 139                 }
 140                 sb.append("&gt; ");
 141             }
 142 
 143             specificToGenericStringHeader(sb);
 144 
 145             sb.append('(');
 146             Type[] params = getGenericParameterTypes();
 147             for (int j = 0; j &lt; params.length; j++) {
 148                 String param = (params[j] instanceof Class)?
 149                     Field.getTypeName((Class)params[j]):
 150                     (params[j].toString());
 151                 if (isVarArgs() &amp;&amp; (j == params.length - 1)) // replace T[] with T...
 152                     param = param.replaceFirst("\\[\\]$", "...");
 153                 sb.append(param);
 154                 if (j &lt; (params.length - 1))
 155                     sb.append(',');
 156             }
 157             sb.append(')');
 158             Type[] exceptions = getGenericExceptionTypes();
 159             if (exceptions.length &gt; 0) {
 160                 sb.append(" throws ");
 161                 for (int k = 0; k &lt; exceptions.length; k++) {
 162                     sb.append((exceptions[k] instanceof Class)?
 163                               ((Class)exceptions[k]).getName():
 164                               exceptions[k].toString());
 165                     if (k &lt; (exceptions.length - 1))
 166                         sb.append(',');
 167                 }
 168             }
 169             return sb.toString();
 170         } catch (Exception e) {
 171             return "&lt;" + e + "&gt;";
 172         }
 173     }
 174 
 175     /**
 176      * Generate toGenericString header information specific to a
 177      * method or constructor.
 178      */
 179     abstract void specificToGenericStringHeader(StringBuilder sb);
 180 
 181     /**
 182      * Returns the {@code Class} object representing the class or interface
 183      * that declares the executable represented by this object.
 184      */
 185     public abstract Class&lt;?&gt; getDeclaringClass();
 186 
 187     /**
 188      * Returns the name of the executable represented by this object.
 189      */
 190     public abstract String getName();
 191 
 192     /**
 193      * Returns the Java language {@linkplain Modifier modifiers} for
 194      * the executable represented by this object.
 195      */
 196     public abstract int getModifiers();
 197 
 198     /**
 199      * Returns an array of {@code TypeVariable} objects that represent the
 200      * type variables declared by the generic declaration represented by this
 201      * {@code GenericDeclaration} object, in declaration order.  Returns an
 202      * array of length 0 if the underlying generic declaration declares no type
 203      * variables.
 204      *
 205      * @return an array of {@code TypeVariable} objects that represent
 206      *     the type variables declared by this generic declaration
 207      * @throws GenericSignatureFormatError if the generic
 208      *     signature of this generic declaration does not conform to
 209      *     the format specified in
 210      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 211      */
 212     public abstract TypeVariable&lt;?&gt;[] getTypeParameters();
 213 
 214     /**
 215      * Returns an array of {@code Class} objects that represent the formal
 216      * parameter types, in declaration order, of the executable
 217      * represented by this object.  Returns an array of length
 218      * 0 if the underlying executable takes no parameters.
 219      *
 220      * @return the parameter types for the executable this object
 221      * represents
 222      */
 223     public abstract Class&lt;?&gt;[] getParameterTypes();
 224 
 225     /**
 226      * Returns an array of {@code Type} objects that represent the formal
 227      * parameter types, in declaration order, of the executable represented by
 228      * this object. Returns an array of length 0 if the
 229      * underlying executable takes no parameters.
 230      *
 231      * &lt;p&gt;If a formal parameter type is a parameterized type,
 232      * the {@code Type} object returned for it must accurately reflect
 233      * the actual type parameters used in the source code.
 234      *
 235      * &lt;p&gt;If a formal parameter type is a type variable or a parameterized
 236      * type, it is created. Otherwise, it is resolved.
 237      *
 238      * @return an array of {@code Type}s that represent the formal
 239      *     parameter types of the underlying executable, in declaration order
 240      * @throws GenericSignatureFormatError
 241      *     if the generic method signature does not conform to the format
 242      *     specified in
 243      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 244      * @throws TypeNotPresentException if any of the parameter
 245      *     types of the underlying executable refers to a non-existent type
 246      *     declaration
 247      * @throws MalformedParameterizedTypeException if any of
 248      *     the underlying executable's parameter types refer to a parameterized
 249      *     type that cannot be instantiated for any reason
 250      */
 251     public Type[] getGenericParameterTypes() {
 252         if (hasGenericInformation())
 253             return getGenericInfo().getParameterTypes();
 254         else
 255             return getParameterTypes();
 256     }
 257 
 258     /**
 259      * Returns an array of {@code Class} objects that represent the
 260      * types of exceptions declared to be thrown by the underlying
 261      * executable represented by this object.  Returns an array of
 262      * length 0 if the executable declares no exceptions in its {@code
 263      * throws} clause.
 264      *
 265      * @return the exception types declared as being thrown by the
 266      * executable this object represents
 267      */
 268     public abstract Class&lt;?&gt;[] getExceptionTypes();
 269 
 270     /**
 271      * Returns an array of {@code Type} objects that represent the
 272      * exceptions declared to be thrown by this executable object.
 273      * Returns an array of length 0 if the underlying executable declares
 274      * no exceptions in its {@code throws} clause.
 275      *
 276      * &lt;p&gt;If an exception type is a type variable or a parameterized
 277      * type, it is created. Otherwise, it is resolved.
 278      *
 279      * @return an array of Types that represent the exception types
 280      *     thrown by the underlying executable
 281      * @throws GenericSignatureFormatError
 282      *     if the generic method signature does not conform to the format
 283      *     specified in
 284      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 285      * @throws TypeNotPresentException if the underlying executable's
 286      *     {@code throws} clause refers to a non-existent type declaration
 287      * @throws MalformedParameterizedTypeException if
 288      *     the underlying executable's {@code throws} clause refers to a
 289      *     parameterized type that cannot be instantiated for any reason
 290      */
 291     public Type[] getGenericExceptionTypes() {
 292         Type[] result;
 293         if (hasGenericInformation() &amp;&amp;
 294             ((result = getGenericInfo().getExceptionTypes()).length &gt; 0))
 295             return result;
 296         else
 297             return getExceptionTypes();
 298     }
 299 
 300     /**
 301      * Returns a string describing this {@code Executable}, including
 302      * any type parameters.
 303      */
 304     public abstract String toGenericString();
 305 
 306     /**
 307      * Returns {@code true} if this executable was declared to take a
 308      * variable number of arguments; returns {@code false} otherwise.
 309      *
 310      * @return {@code true} if an only if this executable was declared
 311      * to take a variable number of arguments.
 312      */
 313     public boolean isVarArgs()  {
 314         return (getModifiers() &amp; Modifier.VARARGS) != 0;
 315     }
 316 
 317     /**
 318      * Returns {@code true} if this executable is a synthetic
 319      * construct; returns {@code false} otherwise.
 320      *
 321      * @return true if and only if this executable is a synthetic
 322      * construct as defined by
 323      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 324      */
 325     public boolean isSynthetic() {
 326         return Modifier.isSynthetic(getModifiers());
 327     }
 328 
 329     /**
 330      * Returns an array of arrays that represent the annotations on
 331      * the formal parameters, in declaration order, of the executable
 332      * represented by this object. (Returns an array of length zero if
 333      * the underlying executable is parameterless.  If the executable has
 334      * one or more parameters, a nested array of length zero is
 335      * returned for each parameter with no annotations.) The
 336      * annotation objects contained in the returned arrays are
 337      * serializable.  The caller of this method is free to modify the
 338      * returned arrays; it will have no effect on the arrays returned
 339      * to other callers.
 340      *
 341      * @return an array of arrays that represent the annotations on the formal
 342      *    parameters, in declaration order, of the executable represented by this
 343      *    object
 344      */
 345     public abstract Annotation[][] getParameterAnnotations();
 346 
 347     Annotation[][] sharedGetParameterAnnotations(Class&lt;?&gt;[] parameterTypes,
 348                                                  byte[] parameterAnnotations) {
 349         int numParameters = parameterTypes.length;
 350         if (parameterAnnotations == null)
 351             return new Annotation[numParameters][0];
 352 
 353         Annotation[][] result = parseParameterAnnotations(parameterAnnotations);
 354 
 355         if (result.length != numParameters)
 356             handleParameterNumberMismatch(result.length, numParameters);
 357         return result;
 358     }
 359 
 360     abstract void handleParameterNumberMismatch(int resultLength, int numParameters);
 361 
 362     /**
 363      * {@inheritDoc}
 364      * @throws NullPointerException  {@inheritDoc}
 365      */
 366     @SuppressWarnings("unchecked")
 367     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 368         if (annotationClass == null)
 369             throw new NullPointerException();
 370 
 371         return (T) declaredAnnotations().get(annotationClass);
 372     }
 373 
 374     /**
 375      * {@inheritDoc}
 376      */
 377     public Annotation[] getDeclaredAnnotations()  {
 378         return AnnotationParser.toArray(declaredAnnotations());
 379     }
 380 
<a name="2" id="anc2"></a><span class="changed"> 381     private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span>
 382 
<a name="3" id="anc3"></a><span class="changed"> 383     private synchronized  Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {</span>

 384         if (declaredAnnotations == null) {
<a name="4" id="anc4"></a><span class="changed"> 385             declaredAnnotations = AnnotationParser.parseAnnotations(</span>
 386                 getAnnotationBytes(),
 387                 sun.misc.SharedSecrets.getJavaLangAccess().
 388                 getConstantPool(getDeclaringClass()),
 389                 getDeclaringClass());
 390         }
 391         return declaredAnnotations;
 392     }
 393 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="5" type="hidden" /></form></body></html>
